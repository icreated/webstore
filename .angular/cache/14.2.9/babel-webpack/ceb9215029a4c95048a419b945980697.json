{"ast":null,"code":"import _assertThisInitialized from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/macspok/projects/idempiere-projects/webstore/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\n * @license Angular v14.2.10\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\nimport * as i0 from '@angular/core';\nimport { ɵisObservable, ɵisPromise, Injectable, ɵRuntimeError, EventEmitter, Directive, Attribute, Output, Component, createEnvironmentInjector, ɵisStandalone, ComponentFactoryResolver, ɵisInjectable, inject, InjectionToken, InjectFlags, NgModuleFactory, Injector, Compiler, NgModuleRef, ɵConsole, NgZone, ɵcoerceToBoolean, Input, HostListener, HostBinding, Optional, ContentChildren, APP_BOOTSTRAP_LISTENER, ApplicationRef, APP_INITIALIZER, ENVIRONMENT_INITIALIZER, NgProbeToken, SkipSelf, NgModule, Inject, Version } from '@angular/core';\nimport { from, of, BehaviorSubject, EmptyError, combineLatest, concat, defer, pipe, throwError, Observable, EMPTY, ConnectableObservable, Subject } from 'rxjs';\nimport * as i3 from '@angular/common';\nimport { Location, ViewportScroller, LOCATION_INITIALIZED, LocationStrategy, HashLocationStrategy, PathLocationStrategy } from '@angular/common';\nimport { map, switchMap, take, startWith, filter, mergeMap, first, concatMap, tap, catchError, scan, last as last$1, takeWhile, defaultIfEmpty, takeLast, mapTo, finalize, refCount, mergeAll } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\n\nvar PRIMARY_OUTLET = 'primary';\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\n\nvar RouteTitleKey = /*#__PURE__*/Symbol('RouteTitle');\n\nvar ParamsAsMap = /*#__PURE__*/function () {\n  function ParamsAsMap(params) {\n    _classCallCheck(this, ParamsAsMap);\n\n    this.params = params || {};\n  }\n\n  _createClass(ParamsAsMap, [{\n    key: \"has\",\n    value: function has(name) {\n      return Object.prototype.hasOwnProperty.call(this.params, name);\n    }\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      if (this.has(name)) {\n        var v = this.params[name];\n        return Array.isArray(v) ? v[0] : v;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll(name) {\n      if (this.has(name)) {\n        var v = this.params[name];\n        return Array.isArray(v) ? v : [v];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return Object.keys(this.params);\n    }\n  }]);\n\n  return ParamsAsMap;\n}();\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\n\n\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see UrlMatchResult\n * @see Route\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\n\n\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  var parts = route.path.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  var posParams = {}; // Check each config part against the actual URL\n\n  for (var index = 0; index < parts.length; index++) {\n    var part = parts[index];\n    var segment = segments[index];\n    var isParameter = part.startsWith(':');\n\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {\n    consumed: segments.slice(0, parts.length),\n    posParams: posParams\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction shallowEqual(a, b) {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  var k1 = a ? Object.keys(a) : undefined;\n  var k2 = b ? Object.keys(b) : undefined;\n\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n\n  var key;\n\n  for (var i = 0; i < k1.length; i++) {\n    key = k1[i];\n\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Test equality for arrays of strings or a string.\n */\n\n\nfunction equalArraysOrString(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n\n    var aSorted = _toConsumableArray(a).sort();\n\n    var bSorted = _toConsumableArray(b).sort();\n\n    return aSorted.every(function (val, index) {\n      return bSorted[index] === val;\n    });\n  } else {\n    return a === b;\n  }\n}\n/**\n * Flattens single-level nested arrays.\n */\n\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n/**\n * Return the last element of an array.\n */\n\n\nfunction last(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n/**\n * Verifys all booleans in an array are `true`.\n */\n\n\nfunction and(bools) {\n  return !bools.some(function (v) {\n    return !v;\n  });\n}\n\nfunction forEach(map, callback) {\n  for (var prop in map) {\n    if (map.hasOwnProperty(prop)) {\n      callback(map[prop], prop);\n    }\n  }\n}\n\nfunction wrapIntoObservable(value) {\n  if (ɵisObservable(value)) {\n    return value;\n  }\n\n  if (ɵisPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$9 = typeof ngDevMode === 'undefined' || ngDevMode;\n\nfunction createEmptyUrlTree() {\n  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n\nvar pathCompareMap = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup\n};\nvar paramCompareMap = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': function ignored() {\n    return true;\n  }\n};\n\nfunction containsTree(container, containee, options) {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n}\n\nfunction equalParams(container, containee) {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(container, containee, matrixParams) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n\n  for (var c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;\n  }\n\n  return true;\n}\n\nfunction containsParams(container, containee) {\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(function (key) {\n    return equalArraysOrString(container[key], containee[key]);\n  });\n}\n\nfunction containsSegmentGroup(container, containee, matrixParams) {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\n\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\n  if (container.segments.length > containeePaths.length) {\n    var current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n\n    for (var c in containee.children) {\n      if (!container.children[c]) return false;\n\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    var _current = containeePaths.slice(0, container.segments.length);\n\n    var next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, _current)) return false;\n    if (!matrixParamsMatch(container.segments, _current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n  }\n}\n\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\n  return containeePaths.every(function (containeeSegment, i) {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\n\n\nvar UrlTree = /*#__PURE__*/function () {\n  /** @internal */\n  function UrlTree(\n  /** The root segment group of the URL tree */\n  root,\n  /** The query params of the URL */\n  queryParams,\n  /** The fragment of the URL */\n  fragment) {\n    _classCallCheck(this, UrlTree);\n\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n  }\n\n  _createClass(UrlTree, [{\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n    /** @docsNotRequired */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return DEFAULT_SERIALIZER.serialize(this);\n    }\n  }]);\n\n  return UrlTree;\n}();\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\n\n\nvar UrlSegmentGroup = /*#__PURE__*/function () {\n  function UrlSegmentGroup(\n  /** The URL segments of this group. See `UrlSegment` for more information */\n  segments,\n  /** The list of children of this group */\n  children) {\n    var _this = this;\n\n    _classCallCheck(this, UrlSegmentGroup);\n\n    this.segments = segments;\n    this.children = children;\n    /** The parent node in the url tree */\n\n    this.parent = null;\n    forEach(children, function (v, k) {\n      return v.parent = _this;\n    });\n  }\n  /** Whether the segment has child segments */\n\n\n  _createClass(UrlSegmentGroup, [{\n    key: \"hasChildren\",\n    value: function hasChildren() {\n      return this.numberOfChildren > 0;\n    }\n    /** Number of child segments */\n\n  }, {\n    key: \"numberOfChildren\",\n    get: function get() {\n      return Object.keys(this.children).length;\n    }\n    /** @docsNotRequired */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePaths(this);\n    }\n  }]);\n\n  return UrlSegmentGroup;\n}();\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\n\n\nvar UrlSegment = /*#__PURE__*/function () {\n  function UrlSegment(\n  /** The path part of a URL segment */\n  path,\n  /** The matrix parameters associated with a segment */\n  parameters) {\n    _classCallCheck(this, UrlSegment);\n\n    this.path = path;\n    this.parameters = parameters;\n  }\n\n  _createClass(UrlSegment, [{\n    key: \"parameterMap\",\n    get: function get() {\n      if (!this._parameterMap) {\n        this._parameterMap = convertToParamMap(this.parameters);\n      }\n\n      return this._parameterMap;\n    }\n    /** @docsNotRequired */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePath(this);\n    }\n  }]);\n\n  return UrlSegment;\n}();\n\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every(function (a, i) {\n    return shallowEqual(a.parameters, bs[i].parameters);\n  });\n}\n\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every(function (a, i) {\n    return a.path === bs[i].path;\n  });\n}\n\nfunction mapChildrenIntoArray(segment, fn) {\n  var res = [];\n  forEach(segment.children, function (child, childOutlet) {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  forEach(segment.children, function (child, childOutlet) {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\n\n\nvar UrlSerializer = /*#__PURE__*/(function () {\n  var UrlSerializer = /*#__PURE__*/_createClass(function UrlSerializer() {\n    _classCallCheck(this, UrlSerializer);\n  });\n\n  UrlSerializer.ɵfac = function UrlSerializer_Factory(t) {\n    return new (t || UrlSerializer)();\n  };\n\n  UrlSerializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlSerializer,\n    factory: function factory() {\n      return function () {\n        return new DefaultUrlSerializer();\n      }();\n    },\n    providedIn: 'root'\n  });\n  return UrlSerializer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\n\n\nvar DefaultUrlSerializer = /*#__PURE__*/function () {\n  function DefaultUrlSerializer() {\n    _classCallCheck(this, DefaultUrlSerializer);\n  }\n\n  _createClass(DefaultUrlSerializer, [{\n    key: \"parse\",\n    value:\n    /** Parses a url into a `UrlTree` */\n    function parse(url) {\n      var p = new UrlParser(url);\n      return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    }\n    /** Converts a `UrlTree` into a url */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(tree) {\n      var segment = \"/\".concat(serializeSegment(tree.root, true));\n      var query = serializeQueryParams(tree.queryParams);\n      var fragment = typeof tree.fragment === \"string\" ? \"#\".concat(encodeUriFragment(tree.fragment)) : '';\n      return \"\".concat(segment).concat(query).concat(fragment);\n    }\n  }]);\n\n  return DefaultUrlSerializer;\n}();\n\nvar DEFAULT_SERIALIZER = /*#__PURE__*/new DefaultUrlSerializer();\n\nfunction serializePaths(segment) {\n  return segment.segments.map(function (p) {\n    return serializePath(p);\n  }).join('/');\n}\n\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    var primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';\n    var children = [];\n    forEach(segment.children, function (v, k) {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(\"\".concat(k, \":\").concat(serializeSegment(v, false)));\n      }\n    });\n    return children.length > 0 ? \"\".concat(primary, \"(\").concat(children.join('//'), \")\") : primary;\n  } else {\n    var _children = mapChildrenIntoArray(segment, function (v, k) {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [\"\".concat(k, \":\").concat(serializeSegment(v, false))];\n    }); // use no parenthesis if the only child is a primary outlet route\n\n\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return \"\".concat(serializePaths(segment), \"/\").concat(_children[0]);\n    }\n\n    return \"\".concat(serializePaths(segment), \"/(\").concat(_children.join('//'), \")\");\n  }\n}\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\n\n\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');\n}\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\n\n\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\n\n\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\n\n\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nfunction decode(s) {\n  return decodeURIComponent(s);\n} // Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\n\n\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nfunction serializePath(path) {\n  return \"\".concat(encodeUriSegment(path.path)).concat(serializeMatrixParams(path.parameters));\n}\n\nfunction serializeMatrixParams(params) {\n  return Object.keys(params).map(function (key) {\n    return \";\".concat(encodeUriSegment(key), \"=\").concat(encodeUriSegment(params[key]));\n  }).join('');\n}\n\nfunction serializeQueryParams(params) {\n  var strParams = Object.keys(params).map(function (name) {\n    var value = params[name];\n    return Array.isArray(value) ? value.map(function (v) {\n      return \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(v));\n    }).join('&') : \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(value));\n  }).filter(function (s) {\n    return !!s;\n  });\n  return strParams.length ? \"?\".concat(strParams.join('&')) : '';\n}\n\nvar SEGMENT_RE = /^[^\\/()?;=#]+/;\n\nfunction matchSegments(str) {\n  var match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nvar QUERY_PARAM_RE = /^[^=?&#]+/; // Return the name of the query param at the start of the string or an empty string\n\nfunction matchQueryParams(str) {\n  var match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nvar QUERY_PARAM_VALUE_RE = /^[^&#]+/; // Return the value of the query param at the start of the string or an empty string\n\nfunction matchUrlQueryParamValue(str) {\n  var match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nvar UrlParser = /*#__PURE__*/function () {\n  function UrlParser(url) {\n    _classCallCheck(this, UrlParser);\n\n    this.url = url;\n    this.remaining = url;\n  }\n\n  _createClass(UrlParser, [{\n    key: \"parseRootSegment\",\n    value: function parseRootSegment() {\n      this.consumeOptional('/');\n\n      if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n        return new UrlSegmentGroup([], {});\n      } // The root segment group never has segments\n\n\n      return new UrlSegmentGroup([], this.parseChildren());\n    }\n  }, {\n    key: \"parseQueryParams\",\n    value: function parseQueryParams() {\n      var params = {};\n\n      if (this.consumeOptional('?')) {\n        do {\n          this.parseQueryParam(params);\n        } while (this.consumeOptional('&'));\n      }\n\n      return params;\n    }\n  }, {\n    key: \"parseFragment\",\n    value: function parseFragment() {\n      return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n    }\n  }, {\n    key: \"parseChildren\",\n    value: function parseChildren() {\n      if (this.remaining === '') {\n        return {};\n      }\n\n      this.consumeOptional('/');\n      var segments = [];\n\n      if (!this.peekStartsWith('(')) {\n        segments.push(this.parseSegment());\n      }\n\n      while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n        this.capture('/');\n        segments.push(this.parseSegment());\n      }\n\n      var children = {};\n\n      if (this.peekStartsWith('/(')) {\n        this.capture('/');\n        children = this.parseParens(true);\n      }\n\n      var res = {};\n\n      if (this.peekStartsWith('(')) {\n        res = this.parseParens(false);\n      }\n\n      if (segments.length > 0 || Object.keys(children).length > 0) {\n        res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n      }\n\n      return res;\n    } // parse a segment with its matrix parameters\n    // ie `name;k1=v1;k2`\n\n  }, {\n    key: \"parseSegment\",\n    value: function parseSegment() {\n      var path = matchSegments(this.remaining);\n\n      if (path === '' && this.peekStartsWith(';')) {\n        throw new ɵRuntimeError(4009\n        /* RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS */\n        , NG_DEV_MODE$9 && \"Empty path url segment cannot have parameters: '\".concat(this.remaining, \"'.\"));\n      }\n\n      this.capture(path);\n      return new UrlSegment(decode(path), this.parseMatrixParams());\n    }\n  }, {\n    key: \"parseMatrixParams\",\n    value: function parseMatrixParams() {\n      var params = {};\n\n      while (this.consumeOptional(';')) {\n        this.parseParam(params);\n      }\n\n      return params;\n    }\n  }, {\n    key: \"parseParam\",\n    value: function parseParam(params) {\n      var key = matchSegments(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      var value = '';\n\n      if (this.consumeOptional('=')) {\n        var valueMatch = matchSegments(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n\n      params[decode(key)] = decode(value);\n    } // Parse a single query parameter `name[=value]`\n\n  }, {\n    key: \"parseQueryParam\",\n    value: function parseQueryParam(params) {\n      var key = matchQueryParams(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      var value = '';\n\n      if (this.consumeOptional('=')) {\n        var valueMatch = matchUrlQueryParamValue(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n\n      var decodedKey = decodeQuery(key);\n      var decodedVal = decodeQuery(value);\n\n      if (params.hasOwnProperty(decodedKey)) {\n        // Append to existing values\n        var currentVal = params[decodedKey];\n\n        if (!Array.isArray(currentVal)) {\n          currentVal = [currentVal];\n          params[decodedKey] = currentVal;\n        }\n\n        currentVal.push(decodedVal);\n      } else {\n        // Create a new value\n        params[decodedKey] = decodedVal;\n      }\n    } // parse `(a/b//outlet_name:c/d)`\n\n  }, {\n    key: \"parseParens\",\n    value: function parseParens(allowPrimary) {\n      var segments = {};\n      this.capture('(');\n\n      while (!this.consumeOptional(')') && this.remaining.length > 0) {\n        var path = matchSegments(this.remaining);\n        var next = this.remaining[path.length]; // if is is not one of these characters, then the segment was unescaped\n        // or the group was not closed\n\n        if (next !== '/' && next !== ')' && next !== ';') {\n          throw new ɵRuntimeError(4010\n          /* RuntimeErrorCode.UNPARSABLE_URL */\n          , NG_DEV_MODE$9 && \"Cannot parse url '\".concat(this.url, \"'\"));\n        }\n\n        var outletName = undefined;\n\n        if (path.indexOf(':') > -1) {\n          outletName = path.slice(0, path.indexOf(':'));\n          this.capture(outletName);\n          this.capture(':');\n        } else if (allowPrimary) {\n          outletName = PRIMARY_OUTLET;\n        }\n\n        var children = this.parseChildren();\n        segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n        this.consumeOptional('//');\n      }\n\n      return segments;\n    }\n  }, {\n    key: \"peekStartsWith\",\n    value: function peekStartsWith(str) {\n      return this.remaining.startsWith(str);\n    } // Consumes the prefix when it is present and returns whether it has been consumed\n\n  }, {\n    key: \"consumeOptional\",\n    value: function consumeOptional(str) {\n      if (this.peekStartsWith(str)) {\n        this.remaining = this.remaining.substring(str.length);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"capture\",\n    value: function capture(str) {\n      if (!this.consumeOptional(str)) {\n        throw new ɵRuntimeError(4011\n        /* RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL */\n        , NG_DEV_MODE$9 && \"Expected \\\"\".concat(str, \"\\\".\"));\n      }\n    }\n  }]);\n\n  return UrlParser;\n}();\n\nfunction createRoot(rootCandidate) {\n  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], _defineProperty({}, PRIMARY_OUTLET, rootCandidate)) : rootCandidate;\n}\n/**\n * Recursively merges primary segment children into their parents and also drops empty children\n * (those which have no segments and no children themselves). The latter prevents serializing a\n * group into something like `/a(aux:)`, where `aux` is an empty child segment.\n */\n\n\nfunction squashSegmentGroup(segmentGroup) {\n  var newChildren = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(segmentGroup.children); _i < _Object$keys.length; _i++) {\n    var childOutlet = _Object$keys[_i];\n    var child = segmentGroup.children[childOutlet];\n    var childCandidate = squashSegmentGroup(child); // don't add empty children\n\n    if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n\n  var s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\n\n\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    var c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nfunction isUrlTree(v) {\n  return v instanceof UrlTree;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$8 = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\n\nfunction createUrlTreeFromSnapshot(relativeTo, commands) {\n  var queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var fragment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\n\nfunction createSegmentGroupFromRoute(route) {\n  var targetGroup;\n\n  function createSegmentGroupFromRouteRecursive(currentRoute) {\n    var childOutlets = {};\n\n    var _iterator = _createForOfIteratorHelper(currentRoute.children),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var childSnapshot = _step.value;\n        var root = createSegmentGroupFromRouteRecursive(childSnapshot);\n        childOutlets[childSnapshot.outlet] = root;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n\n    return segmentGroup;\n  }\n\n  var rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  var rootSegmentGroup = createRoot(rootCandidate);\n  return targetGroup !== null && targetGroup !== void 0 ? targetGroup : rootSegmentGroup;\n}\n\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {\n  var root = relativeTo;\n\n  while (root.parent) {\n    root = root.parent;\n  } // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n\n\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n\n  var nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  var position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  var newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\n\nfunction _createUrlTree(route, urlTree, commands, queryParams, fragment) {\n  var _a, _b;\n\n  if (commands.length === 0) {\n    return tree(urlTree.root, urlTree.root, urlTree.root, queryParams, fragment);\n  }\n\n  var nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(urlTree.root, urlTree.root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  function createTreeUsingPathIndex(lastPathIndex) {\n    var _a;\n\n    var startingPosition = findStartingPosition(nav, urlTree, (_a = route.snapshot) === null || _a === void 0 ? void 0 : _a._urlSegment, lastPathIndex);\n    var segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n    return tree(urlTree.root, startingPosition.segmentGroup, segmentGroup, queryParams, fragment);\n  } // Note: The types should disallow `snapshot` from being `undefined` but due to test mocks, this\n  // may be the case. Since we try to access it at an earlier point before the refactor to add the\n  // warning for `relativeLinkResolution: 'legacy'`, this may cause failures in tests where it\n  // didn't before.\n\n\n  var result = createTreeUsingPathIndex((_a = route.snapshot) === null || _a === void 0 ? void 0 : _a._lastPathIndex); // Check if application is relying on `relativeLinkResolution: 'legacy'`\n\n  if (typeof ngDevMode === 'undefined' || !!ngDevMode) {\n    var correctedResult = createTreeUsingPathIndex((_b = route.snapshot) === null || _b === void 0 ? void 0 : _b._correctedLastPathIndex);\n\n    if (correctedResult.toString() !== result.toString()) {\n      console.warn(\"relativeLinkResolution: 'legacy' is deprecated and will be removed in a future version of Angular. The link to \".concat(result.toString(), \" will change to \").concat(correctedResult.toString(), \" if the code is not updated before then.\"));\n    }\n  }\n\n  return result;\n}\n\nfunction isMatrixParams(command) {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\n\n\nfunction isCommandWithOutlets(command) {\n  return typeof command === 'object' && command != null && command.outlets;\n}\n\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {\n  var qp = {};\n\n  if (queryParams) {\n    forEach(queryParams, function (value, name) {\n      qp[name] = Array.isArray(value) ? value.map(function (v) {\n        return \"\".concat(v);\n      }) : \"\".concat(value);\n    });\n  }\n\n  var rootCandidate;\n\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n\n  var newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\n\n\nfunction replaceSegment(current, oldSegment, newSegment) {\n  var children = {};\n  forEach(current.children, function (c, outletName) {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nvar Navigation = /*#__PURE__*/function () {\n  function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n    _classCallCheck(this, Navigation);\n\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new ɵRuntimeError(4003\n      /* RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS */\n      , NG_DEV_MODE$8 && 'Root segment cannot have matrix parameters');\n    }\n\n    var cmdWithOutlet = commands.find(isCommandWithOutlets);\n\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new ɵRuntimeError(4004\n      /* RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND */\n      , NG_DEV_MODE$8 && '{outlets:{}} has to be the last command');\n    }\n  }\n\n  _createClass(Navigation, [{\n    key: \"toRoot\",\n    value: function toRoot() {\n      return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    }\n  }]);\n\n  return Navigation;\n}();\n/** Transforms commands to a normalized `Navigation` */\n\n\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  var numberOfDoubleDots = 0;\n  var isAbsolute = false;\n  var res = commands.reduce(function (res, cmd, cmdIdx) {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        var outlets = {};\n        forEach(cmd.outlets, function (commands, name) {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [].concat(_toConsumableArray(res), [{\n          outlets: outlets\n        }]);\n      }\n\n      if (cmd.segmentPath) {\n        return [].concat(_toConsumableArray(res), [cmd.segmentPath]);\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [].concat(_toConsumableArray(res), [cmd]);\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach(function (urlPart, partIndex) {\n        if (partIndex == 0 && urlPart === '.') {// skip './a'\n        } else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n      return res;\n    }\n\n    return [].concat(_toConsumableArray(res), [cmd]);\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nvar Position = /*#__PURE__*/_createClass(function Position(segmentGroup, processChildren, index) {\n  _classCallCheck(this, Position);\n\n  this.segmentGroup = segmentGroup;\n  this.processChildren = processChildren;\n  this.index = index;\n});\n\nfunction findStartingPositionForTargetGroup(nav, root, target) {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n\n  var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  var index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\n\nfunction findStartingPosition(nav, tree, segmentGroup, lastPathIndex) {\n  if (nav.isAbsolute) {\n    return new Position(tree.root, true, 0);\n  }\n\n  if (lastPathIndex === -1) {\n    // Pathless ActivatedRoute has _lastPathIndex === -1 but should not process children\n    // see issue #26224, #13011, #35687\n    // However, if the ActivatedRoute is the root we should process children like above.\n    var processChildren = segmentGroup === tree.root;\n    return new Position(segmentGroup, processChildren, 0);\n  }\n\n  var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  var index = lastPathIndex + modifier;\n  return createPositionApplyingDoubleDots(segmentGroup, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  var g = group;\n  var ci = index;\n  var dd = numberOfDoubleDots;\n\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent;\n\n    if (!g) {\n      throw new ɵRuntimeError(4005\n      /* RuntimeErrorCode.INVALID_DOUBLE_DOTS */\n      , NG_DEV_MODE$8 && 'Invalid number of \\'../\\'');\n    }\n\n    ci = g.segments.length;\n  }\n\n  return new Position(g, false, ci - dd);\n}\n\nfunction getOutlets(commands) {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n\n  return _defineProperty({}, PRIMARY_OUTLET, commands);\n}\n\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  if (!segmentGroup) {\n    segmentGroup = new UrlSegmentGroup([], {});\n  }\n\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  var m = prefixedWith(segmentGroup, startIndex, commands);\n  var slicedCommands = commands.slice(m.commandIndex);\n\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    var outlets = getOutlets(commands);\n    var children = {};\n    forEach(outlets, function (commands, outlet) {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n    forEach(segmentGroup.children, function (child, childOutlet) {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  var currentCommandIndex = 0;\n  var currentPathIndex = startIndex;\n  var noMatch = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    var path = segmentGroup.segments[currentPathIndex];\n    var command = commands[currentCommandIndex]; // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n\n    var curr = \"\".concat(command);\n    var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n\n    currentPathIndex++;\n  }\n\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\n\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  var paths = segmentGroup.segments.slice(0, startIndex);\n  var i = 0;\n\n  while (i < commands.length) {\n    var command = commands[i];\n\n    if (isCommandWithOutlets(command)) {\n      var children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    } // if we start with an object literal, we need to reuse the path part from the segment\n\n\n    if (i === 0 && isMatrixParams(commands[0])) {\n      var p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n\n    var curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : \"\".concat(command);\n    var next = i < commands.length - 1 ? commands[i + 1] : null;\n\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets) {\n  var children = {};\n  forEach(outlets, function (commands, outlet) {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params) {\n  var res = {};\n  forEach(params, function (v, k) {\n    return res[k] = \"\".concat(v);\n  });\n  return res;\n}\n\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * @see [Router events summary](guide/router-reference#router-events)\n * @publicApi\n */\n\n\nvar RouterEvent = /*#__PURE__*/_createClass(function RouterEvent(\n/** A unique ID that the router assigns to every router navigation. */\nid,\n/** The URL that is the destination for this navigation. */\nurl) {\n  _classCallCheck(this, RouterEvent);\n\n  this.id = id;\n  this.url = url;\n});\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\n\n\nvar NavigationStart = /*#__PURE__*/function (_RouterEvent) {\n  _inherits(NavigationStart, _RouterEvent);\n\n  var _super = _createSuper(NavigationStart);\n\n  function NavigationStart(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url) {\n    var _this2;\n\n    var navigationTrigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'imperative';\n    var restoredState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, NavigationStart);\n\n    _this2 = _super.call(this, id, url);\n    _this2.type = 0\n    /* EventType.NavigationStart */\n    ;\n    _this2.navigationTrigger = navigationTrigger;\n    _this2.restoredState = restoredState;\n    return _this2;\n  }\n  /** @docsNotRequired */\n\n\n  _createClass(NavigationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationStart;\n}(RouterEvent);\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see `NavigationStart`\n * @see `NavigationCancel`\n * @see `NavigationError`\n *\n * @publicApi\n */\n\n\nvar NavigationEnd = /*#__PURE__*/function (_RouterEvent2) {\n  _inherits(NavigationEnd, _RouterEvent2);\n\n  var _super2 = _createSuper(NavigationEnd);\n\n  function NavigationEnd(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /** @docsNotRequired */\n  urlAfterRedirects) {\n    var _this3;\n\n    _classCallCheck(this, NavigationEnd);\n\n    _this3 = _super2.call(this, id, url);\n    _this3.urlAfterRedirects = urlAfterRedirects;\n    _this3.type = 1\n    /* EventType.NavigationEnd */\n    ;\n    return _this3;\n  }\n  /** @docsNotRequired */\n\n\n  _createClass(NavigationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"')\");\n    }\n  }]);\n\n  return NavigationEnd;\n}(RouterEvent);\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationError`\n *\n * @publicApi\n */\n\n\nvar NavigationCancel = /*#__PURE__*/function (_RouterEvent3) {\n  _inherits(NavigationCancel, _RouterEvent3);\n\n  var _super3 = _createSuper(NavigationCancel);\n\n  function NavigationCancel(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /**\n   * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n   * instead for a stable cancellation reason that can be used in production.\n   */\n  reason,\n  /**\n   * A code to indicate why the navigation was canceled. This cancellation code is stable for\n   * the reason and can be relied on whereas the `reason` string could change and should not be\n   * used in production.\n   */\n  code) {\n    var _this4;\n\n    _classCallCheck(this, NavigationCancel);\n\n    _this4 = _super3.call(this, id, url);\n    _this4.reason = reason;\n    _this4.code = code;\n    _this4.type = 2\n    /* EventType.NavigationCancel */\n    ;\n    return _this4;\n  }\n  /** @docsNotRequired */\n\n\n  _createClass(NavigationCancel, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationCancel(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationCancel;\n}(RouterEvent);\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationCancel`\n *\n * @publicApi\n */\n\n\nvar NavigationError = /*#__PURE__*/function (_RouterEvent4) {\n  _inherits(NavigationError, _RouterEvent4);\n\n  var _super4 = _createSuper(NavigationError);\n\n  function NavigationError(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /** @docsNotRequired */\n  error,\n  /**\n   * The target of the navigation when the error occurred.\n   *\n   * Note that this can be `undefined` because an error could have occurred before the\n   * `RouterStateSnapshot` was created for the navigation.\n   */\n  target) {\n    var _this5;\n\n    _classCallCheck(this, NavigationError);\n\n    _this5 = _super4.call(this, id, url);\n    _this5.error = error;\n    _this5.target = target;\n    _this5.type = 3\n    /* EventType.NavigationError */\n    ;\n    return _this5;\n  }\n  /** @docsNotRequired */\n\n\n  _createClass(NavigationError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationError(id: \".concat(this.id, \", url: '\").concat(this.url, \"', error: \").concat(this.error, \")\");\n    }\n  }]);\n\n  return NavigationError;\n}(RouterEvent);\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\n\n\nvar RoutesRecognized = /*#__PURE__*/function (_RouterEvent5) {\n  _inherits(RoutesRecognized, _RouterEvent5);\n\n  var _super5 = _createSuper(RoutesRecognized);\n\n  function RoutesRecognized(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /** @docsNotRequired */\n  urlAfterRedirects,\n  /** @docsNotRequired */\n  state) {\n    var _this6;\n\n    _classCallCheck(this, RoutesRecognized);\n\n    _this6 = _super5.call(this, id, url);\n    _this6.urlAfterRedirects = urlAfterRedirects;\n    _this6.state = state;\n    _this6.type = 4\n    /* EventType.RoutesRecognized */\n    ;\n    return _this6;\n  }\n  /** @docsNotRequired */\n\n\n  _createClass(RoutesRecognized, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RoutesRecognized(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return RoutesRecognized;\n}(RouterEvent);\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see `GuardsCheckEnd`\n *\n * @publicApi\n */\n\n\nvar GuardsCheckStart = /*#__PURE__*/function (_RouterEvent6) {\n  _inherits(GuardsCheckStart, _RouterEvent6);\n\n  var _super6 = _createSuper(GuardsCheckStart);\n\n  function GuardsCheckStart(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /** @docsNotRequired */\n  urlAfterRedirects,\n  /** @docsNotRequired */\n  state) {\n    var _this7;\n\n    _classCallCheck(this, GuardsCheckStart);\n\n    _this7 = _super6.call(this, id, url);\n    _this7.urlAfterRedirects = urlAfterRedirects;\n    _this7.state = state;\n    _this7.type = 7\n    /* EventType.GuardsCheckStart */\n    ;\n    return _this7;\n  }\n\n  _createClass(GuardsCheckStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return GuardsCheckStart;\n}(RouterEvent);\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see `GuardsCheckStart`\n *\n * @publicApi\n */\n\n\nvar GuardsCheckEnd = /*#__PURE__*/function (_RouterEvent7) {\n  _inherits(GuardsCheckEnd, _RouterEvent7);\n\n  var _super7 = _createSuper(GuardsCheckEnd);\n\n  function GuardsCheckEnd(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /** @docsNotRequired */\n  urlAfterRedirects,\n  /** @docsNotRequired */\n  state,\n  /** @docsNotRequired */\n  shouldActivate) {\n    var _this8;\n\n    _classCallCheck(this, GuardsCheckEnd);\n\n    _this8 = _super7.call(this, id, url);\n    _this8.urlAfterRedirects = urlAfterRedirects;\n    _this8.state = state;\n    _this8.shouldActivate = shouldActivate;\n    _this8.type = 8\n    /* EventType.GuardsCheckEnd */\n    ;\n    return _this8;\n  }\n\n  _createClass(GuardsCheckEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \", shouldActivate: \").concat(this.shouldActivate, \")\");\n    }\n  }]);\n\n  return GuardsCheckEnd;\n}(RouterEvent);\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see `ResolveEnd`\n *\n * @publicApi\n */\n\n\nvar ResolveStart = /*#__PURE__*/function (_RouterEvent8) {\n  _inherits(ResolveStart, _RouterEvent8);\n\n  var _super8 = _createSuper(ResolveStart);\n\n  function ResolveStart(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /** @docsNotRequired */\n  urlAfterRedirects,\n  /** @docsNotRequired */\n  state) {\n    var _this9;\n\n    _classCallCheck(this, ResolveStart);\n\n    _this9 = _super8.call(this, id, url);\n    _this9.urlAfterRedirects = urlAfterRedirects;\n    _this9.state = state;\n    _this9.type = 5\n    /* EventType.ResolveStart */\n    ;\n    return _this9;\n  }\n\n  _createClass(ResolveStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveStart;\n}(RouterEvent);\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * @publicApi\n */\n\n\nvar ResolveEnd = /*#__PURE__*/function (_RouterEvent9) {\n  _inherits(ResolveEnd, _RouterEvent9);\n\n  var _super9 = _createSuper(ResolveEnd);\n\n  function ResolveEnd(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url,\n  /** @docsNotRequired */\n  urlAfterRedirects,\n  /** @docsNotRequired */\n  state) {\n    var _this10;\n\n    _classCallCheck(this, ResolveEnd);\n\n    _this10 = _super9.call(this, id, url);\n    _this10.urlAfterRedirects = urlAfterRedirects;\n    _this10.state = state;\n    _this10.type = 6\n    /* EventType.ResolveEnd */\n    ;\n    return _this10;\n  }\n\n  _createClass(ResolveEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveEnd;\n}(RouterEvent);\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see `RouteConfigLoadEnd`\n *\n * @publicApi\n */\n\n\nvar RouteConfigLoadStart = /*#__PURE__*/function () {\n  function RouteConfigLoadStart(\n  /** @docsNotRequired */\n  route) {\n    _classCallCheck(this, RouteConfigLoadStart);\n\n    this.route = route;\n    this.type = 9\n    /* EventType.RouteConfigLoadStart */\n    ;\n  }\n\n  _createClass(RouteConfigLoadStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadStart(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadStart;\n}();\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see `RouteConfigLoadStart`\n *\n * @publicApi\n */\n\n\nvar RouteConfigLoadEnd = /*#__PURE__*/function () {\n  function RouteConfigLoadEnd(\n  /** @docsNotRequired */\n  route) {\n    _classCallCheck(this, RouteConfigLoadEnd);\n\n    this.route = route;\n    this.type = 10\n    /* EventType.RouteConfigLoadEnd */\n    ;\n  }\n\n  _createClass(RouteConfigLoadEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadEnd(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadEnd;\n}();\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see  `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\n\n\nvar ChildActivationStart = /*#__PURE__*/function () {\n  function ChildActivationStart(\n  /** @docsNotRequired */\n  snapshot) {\n    _classCallCheck(this, ChildActivationStart);\n\n    this.snapshot = snapshot;\n    this.type = 11\n    /* EventType.ChildActivationStart */\n    ;\n  }\n\n  _createClass(ChildActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationStart;\n}();\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart`\n * @publicApi\n */\n\n\nvar ChildActivationEnd = /*#__PURE__*/function () {\n  function ChildActivationEnd(\n  /** @docsNotRequired */\n  snapshot) {\n    _classCallCheck(this, ChildActivationEnd);\n\n    this.snapshot = snapshot;\n    this.type = 12\n    /* EventType.ChildActivationEnd */\n    ;\n  }\n\n  _createClass(ChildActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationEnd;\n}();\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\n\n\nvar ActivationStart = /*#__PURE__*/function () {\n  function ActivationStart(\n  /** @docsNotRequired */\n  snapshot) {\n    _classCallCheck(this, ActivationStart);\n\n    this.snapshot = snapshot;\n    this.type = 13\n    /* EventType.ActivationStart */\n    ;\n  }\n\n  _createClass(ActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationStart;\n}();\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * @publicApi\n */\n\n\nvar ActivationEnd = /*#__PURE__*/function () {\n  function ActivationEnd(\n  /** @docsNotRequired */\n  snapshot) {\n    _classCallCheck(this, ActivationEnd);\n\n    this.snapshot = snapshot;\n    this.type = 14\n    /* EventType.ActivationEnd */\n    ;\n  }\n\n  _createClass(ActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationEnd;\n}();\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\n\n\nvar Scroll = /*#__PURE__*/function () {\n  function Scroll(\n  /** @docsNotRequired */\n  routerEvent,\n  /** @docsNotRequired */\n  position,\n  /** @docsNotRequired */\n  anchor) {\n    _classCallCheck(this, Scroll);\n\n    this.routerEvent = routerEvent;\n    this.position = position;\n    this.anchor = anchor;\n    this.type = 15\n    /* EventType.Scroll */\n    ;\n  }\n\n  _createClass(Scroll, [{\n    key: \"toString\",\n    value: function toString() {\n      var pos = this.position ? \"\".concat(this.position[0], \", \").concat(this.position[1]) : null;\n      return \"Scroll(anchor: '\".concat(this.anchor, \"', position: '\").concat(pos, \"')\");\n    }\n  }]);\n\n  return Scroll;\n}();\n\nfunction stringifyEvent(routerEvent) {\n  var _a, _b, _c, _d;\n\n  if (!('type' in routerEvent)) {\n    return \"Unknown Router Event: \".concat(routerEvent.constructor.name);\n  }\n\n  switch (routerEvent.type) {\n    case 14\n    /* EventType.ActivationEnd */\n    :\n      return \"ActivationEnd(path: '\".concat(((_a = routerEvent.snapshot.routeConfig) === null || _a === void 0 ? void 0 : _a.path) || '', \"')\");\n\n    case 13\n    /* EventType.ActivationStart */\n    :\n      return \"ActivationStart(path: '\".concat(((_b = routerEvent.snapshot.routeConfig) === null || _b === void 0 ? void 0 : _b.path) || '', \"')\");\n\n    case 12\n    /* EventType.ChildActivationEnd */\n    :\n      return \"ChildActivationEnd(path: '\".concat(((_c = routerEvent.snapshot.routeConfig) === null || _c === void 0 ? void 0 : _c.path) || '', \"')\");\n\n    case 11\n    /* EventType.ChildActivationStart */\n    :\n      return \"ChildActivationStart(path: '\".concat(((_d = routerEvent.snapshot.routeConfig) === null || _d === void 0 ? void 0 : _d.path) || '', \"')\");\n\n    case 8\n    /* EventType.GuardsCheckEnd */\n    :\n      return \"GuardsCheckEnd(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"', urlAfterRedirects: '\").concat(routerEvent.urlAfterRedirects, \"', state: \").concat(routerEvent.state, \", shouldActivate: \").concat(routerEvent.shouldActivate, \")\");\n\n    case 7\n    /* EventType.GuardsCheckStart */\n    :\n      return \"GuardsCheckStart(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"', urlAfterRedirects: '\").concat(routerEvent.urlAfterRedirects, \"', state: \").concat(routerEvent.state, \")\");\n\n    case 2\n    /* EventType.NavigationCancel */\n    :\n      return \"NavigationCancel(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"')\");\n\n    case 1\n    /* EventType.NavigationEnd */\n    :\n      return \"NavigationEnd(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"', urlAfterRedirects: '\").concat(routerEvent.urlAfterRedirects, \"')\");\n\n    case 3\n    /* EventType.NavigationError */\n    :\n      return \"NavigationError(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"', error: \").concat(routerEvent.error, \")\");\n\n    case 0\n    /* EventType.NavigationStart */\n    :\n      return \"NavigationStart(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"')\");\n\n    case 6\n    /* EventType.ResolveEnd */\n    :\n      return \"ResolveEnd(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"', urlAfterRedirects: '\").concat(routerEvent.urlAfterRedirects, \"', state: \").concat(routerEvent.state, \")\");\n\n    case 5\n    /* EventType.ResolveStart */\n    :\n      return \"ResolveStart(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"', urlAfterRedirects: '\").concat(routerEvent.urlAfterRedirects, \"', state: \").concat(routerEvent.state, \")\");\n\n    case 10\n    /* EventType.RouteConfigLoadEnd */\n    :\n      return \"RouteConfigLoadEnd(path: \".concat(routerEvent.route.path, \")\");\n\n    case 9\n    /* EventType.RouteConfigLoadStart */\n    :\n      return \"RouteConfigLoadStart(path: \".concat(routerEvent.route.path, \")\");\n\n    case 4\n    /* EventType.RoutesRecognized */\n    :\n      return \"RoutesRecognized(id: \".concat(routerEvent.id, \", url: '\").concat(routerEvent.url, \"', urlAfterRedirects: '\").concat(routerEvent.urlAfterRedirects, \"', state: \").concat(routerEvent.state, \")\");\n\n    case 15\n    /* EventType.Scroll */\n    :\n      var pos = routerEvent.position ? \"\".concat(routerEvent.position[0], \", \").concat(routerEvent.position[1]) : null;\n      return \"Scroll(anchor: '\".concat(routerEvent.anchor, \"', position: '\").concat(pos, \"')\");\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar Tree = /*#__PURE__*/function () {\n  function Tree(root) {\n    _classCallCheck(this, Tree);\n\n    this._root = root;\n  }\n\n  _createClass(Tree, [{\n    key: \"root\",\n    get: function get() {\n      return this._root.value;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent(t) {\n      var p = this.pathFromRoot(t);\n      return p.length > 1 ? p[p.length - 2] : null;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"children\",\n    value: function children(t) {\n      var n = findNode(t, this._root);\n      return n ? n.children.map(function (t) {\n        return t.value;\n      }) : [];\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild(t) {\n      var n = findNode(t, this._root);\n      return n && n.children.length > 0 ? n.children[0].value : null;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"siblings\",\n    value: function siblings(t) {\n      var p = findPath(t, this._root);\n      if (p.length < 2) return [];\n      var c = p[p.length - 2].children.map(function (c) {\n        return c.value;\n      });\n      return c.filter(function (cc) {\n        return cc !== t;\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    value: function pathFromRoot(t) {\n      return findPath(t, this._root).map(function (s) {\n        return s.value;\n      });\n    }\n  }]);\n\n  return Tree;\n}(); // DFS for the node matching the value\n\n\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n\n  var _iterator2 = _createForOfIteratorHelper(node.children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n\n      var _node = findNode(value, child);\n\n      if (_node) return _node;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return null;\n} // Return the path to the node with the given value using DFS\n\n\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n\n  var _iterator3 = _createForOfIteratorHelper(node.children),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var child = _step3.value;\n      var path = findPath(value, child);\n\n      if (path.length) {\n        path.unshift(node);\n        return path;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return [];\n}\n\nvar TreeNode = /*#__PURE__*/function () {\n  function TreeNode(value, children) {\n    _classCallCheck(this, TreeNode);\n\n    this.value = value;\n    this.children = children;\n  }\n\n  _createClass(TreeNode, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"TreeNode(\".concat(this.value, \")\");\n    }\n  }]);\n\n  return TreeNode;\n}(); // Return the list of T indexed by outlet name\n\n\nfunction nodeChildrenAsMap(node) {\n  var map = {};\n\n  if (node) {\n    node.children.forEach(function (child) {\n      return map[child.value.outlet] = child;\n    });\n  }\n\n  return map;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see `ActivatedRoute`\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\n\n\nvar RouterState = /*#__PURE__*/function (_Tree) {\n  _inherits(RouterState, _Tree);\n\n  var _super10 = _createSuper(RouterState);\n\n  /** @internal */\n  function RouterState(root,\n  /** The current snapshot of the router state */\n  snapshot) {\n    var _this11;\n\n    _classCallCheck(this, RouterState);\n\n    _this11 = _super10.call(this, root);\n    _this11.snapshot = snapshot;\n    setRouterState(_assertThisInitialized(_this11), root);\n    return _this11;\n  }\n\n  _createClass(RouterState, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot.toString();\n    }\n  }]);\n\n  return RouterState;\n}(Tree);\n\nfunction createEmptyState(urlTree, rootComponent) {\n  var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n  var emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  var emptyParams = new BehaviorSubject({});\n  var emptyData = new BehaviorSubject({});\n  var emptyQueryParams = new BehaviorSubject({});\n  var fragment = new BehaviorSubject('');\n  var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\n\nfunction createEmptyStateSnapshot(urlTree, rootComponent) {\n  var emptyParams = {};\n  var emptyData = {};\n  var emptyQueryParams = {};\n  var fragment = '';\n  var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n  return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\n\n\nvar ActivatedRoute = /*#__PURE__*/function () {\n  /** @internal */\n  function ActivatedRoute(\n  /** An observable of the URL segments matched by this route. */\n  url,\n  /** An observable of the matrix parameters scoped to this route. */\n  params,\n  /** An observable of the query parameters shared by all the routes. */\n  queryParams,\n  /** An observable of the URL fragment shared by all the routes. */\n  fragment,\n  /** An observable of the static and resolved data of this route. */\n  data,\n  /** The outlet name of the route, a constant. */\n  outlet,\n  /** The component of the route, a constant. */\n  component, futureSnapshot) {\n    _classCallCheck(this, ActivatedRoute);\n\n    var _a, _b;\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    /** An Observable of the resolved route title */\n\n    this.title = (_b = (_a = this.data) === null || _a === void 0 ? void 0 : _a.pipe(map(function (d) {\n      return d[RouteTitleKey];\n    }))) !== null && _b !== void 0 ? _b : of(undefined);\n    this._futureSnapshot = futureSnapshot;\n  }\n  /** The configuration used to match this route. */\n\n\n  _createClass(ActivatedRoute, [{\n    key: \"routeConfig\",\n    get: function get() {\n      return this._futureSnapshot.routeConfig;\n    }\n    /** The root of the router state. */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /** The parent of this route in the router state tree. */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /** The first child of this route in the router state tree. */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /** The children of this route in the router state tree. */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /** The path from the root of the router state tree to this route. */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * An Observable that contains a map of the required and optional parameters\n     * specific to the route.\n     * The map supports retrieving single and multiple values from the same parameter.\n     */\n\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = this.params.pipe(map(function (p) {\n          return convertToParamMap(p);\n        }));\n      }\n\n      return this._paramMap;\n    }\n    /**\n     * An Observable that contains a map of the query parameters available to all routes.\n     * The map supports retrieving single and multiple values from the query parameter.\n     */\n\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = this.queryParams.pipe(map(function (p) {\n          return convertToParamMap(p);\n        }));\n      }\n\n      return this._queryParamMap;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot ? this.snapshot.toString() : \"Future(\".concat(this._futureSnapshot, \")\");\n    }\n  }]);\n\n  return ActivatedRoute;\n}();\n/**\n * Returns the inherited params, data, and resolve for a given route.\n * By default, this only inherits values up to the nearest path-less or component-less route.\n * @internal\n */\n\n\nfunction inheritedParamsDataResolve(route) {\n  var paramsInheritanceStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'emptyOnly';\n  var pathFromRoot = route.pathFromRoot;\n  var inheritingStartingFrom = 0;\n\n  if (paramsInheritanceStrategy !== 'always') {\n    inheritingStartingFrom = pathFromRoot.length - 1;\n\n    while (inheritingStartingFrom >= 1) {\n      var current = pathFromRoot[inheritingStartingFrom];\n      var parent = pathFromRoot[inheritingStartingFrom - 1]; // current route is an empty path => inherits its parent's params and data\n\n      if (current.routeConfig && current.routeConfig.path === '') {\n        inheritingStartingFrom--; // parent is componentless => current route should inherit its params and data\n      } else if (!parent.component) {\n        inheritingStartingFrom--;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\n}\n/** @internal */\n\n\nfunction flattenInherited(pathFromRoot) {\n  return pathFromRoot.reduce(function (res, curr) {\n    var _a;\n\n    var params = Object.assign(Object.assign({}, res.params), curr.params);\n    var data = Object.assign(Object.assign({}, res.data), curr.data);\n    var resolve = Object.assign(Object.assign(Object.assign(Object.assign({}, curr.data), res.resolve), (_a = curr.routeConfig) === null || _a === void 0 ? void 0 : _a.data), curr._resolvedData);\n    return {\n      params: params,\n      data: data,\n      resolve: resolve\n    };\n  }, {\n    params: {},\n    data: {},\n    resolve: {}\n  });\n}\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\n\n\nvar ActivatedRouteSnapshot = /*#__PURE__*/function () {\n  /** @internal */\n  function ActivatedRouteSnapshot(\n  /** The URL segments matched by this route */\n  url,\n  /**\n   *  The matrix parameters scoped to this route.\n   *\n   *  You can compute all params (or data) in the router state or to get params outside\n   *  of an activated component by traversing the `RouterState` tree as in the following\n   *  example:\n   *  ```\n   *  collectRouteParams(router: Router) {\n   *    let params = {};\n   *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n   *    while (stack.length > 0) {\n   *      const route = stack.pop()!;\n   *      params = {...params, ...route.params};\n   *      stack.push(...route.children);\n   *    }\n   *    return params;\n   *  }\n   *  ```\n   */\n  params,\n  /** The query parameters shared by all the routes */\n  queryParams,\n  /** The URL fragment shared by all the routes */\n  fragment,\n  /** The static and resolved data of this route */\n  data,\n  /** The outlet name of the route */\n  outlet,\n  /** The component of the route */\n  component, routeConfig, urlSegment, lastPathIndex, resolve, correctedLastPathIndex) {\n    _classCallCheck(this, ActivatedRouteSnapshot);\n\n    var _a;\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    /** The resolved route title */\n\n    this.title = (_a = this.data) === null || _a === void 0 ? void 0 : _a[RouteTitleKey];\n    this.routeConfig = routeConfig;\n    this._urlSegment = urlSegment;\n    this._lastPathIndex = lastPathIndex;\n    this._correctedLastPathIndex = correctedLastPathIndex !== null && correctedLastPathIndex !== void 0 ? correctedLastPathIndex : lastPathIndex;\n    this._resolve = resolve;\n  }\n  /** The root of the router state */\n\n\n  _createClass(ActivatedRouteSnapshot, [{\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /** The parent of this route in the router state tree */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /** The first child of this route in the router state tree */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /** The children of this route in the router state tree */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /** The path from the root of the router state tree to this route */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = convertToParamMap(this.params);\n      }\n\n      return this._paramMap;\n    }\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var url = this.url.map(function (segment) {\n        return segment.toString();\n      }).join('/');\n      var matched = this.routeConfig ? this.routeConfig.path : '';\n      return \"Route(url:'\".concat(url, \"', path:'\").concat(matched, \"')\");\n    }\n  }]);\n\n  return ActivatedRouteSnapshot;\n}();\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\n\n\nvar RouterStateSnapshot = /*#__PURE__*/function (_Tree2) {\n  _inherits(RouterStateSnapshot, _Tree2);\n\n  var _super11 = _createSuper(RouterStateSnapshot);\n\n  /** @internal */\n  function RouterStateSnapshot(\n  /** The url from which this snapshot was created */\n  url, root) {\n    var _this12;\n\n    _classCallCheck(this, RouterStateSnapshot);\n\n    _this12 = _super11.call(this, root);\n    _this12.url = url;\n    setRouterState(_assertThisInitialized(_this12), root);\n    return _this12;\n  }\n\n  _createClass(RouterStateSnapshot, [{\n    key: \"toString\",\n    value: function toString() {\n      return serializeNode(this._root);\n    }\n  }]);\n\n  return RouterStateSnapshot;\n}(Tree);\n\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach(function (c) {\n    return setRouterState(state, c);\n  });\n}\n\nfunction serializeNode(node) {\n  var c = node.children.length > 0 ? \" { \".concat(node.children.map(serializeNode).join(', '), \" } \") : '';\n  return \"\".concat(node.value).concat(c);\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\n\n\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    var currentSnapshot = route.snapshot;\n    var nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParams.next(nextSnapshot.queryParams);\n    }\n\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragment.next(nextSnapshot.fragment);\n    }\n\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.params.next(nextSnapshot.params);\n    }\n\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.url.next(nextSnapshot.url);\n    }\n\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.data.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot; // this is for resolved data\n\n    route.data.next(route._futureSnapshot.data);\n  }\n}\n\nfunction equalParamsAndUrlSegments(a, b) {\n  var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  var parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    var value = prevState.value;\n    value._futureSnapshot = curr.value;\n    var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      // retrieve an activated route that is used to be displayed, but is not currently displayed\n      var detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n\n      if (detachedRouteHandle !== null) {\n        var _tree = detachedRouteHandle.route;\n        _tree.value._futureSnapshot = curr.value;\n        _tree.children = curr.children.map(function (c) {\n          return createNode(routeReuseStrategy, c);\n        });\n        return _tree;\n      }\n    }\n\n    var _value = createActivatedRoute(curr.value);\n\n    var _children2 = curr.children.map(function (c) {\n      return createNode(routeReuseStrategy, c);\n    });\n\n    return new TreeNode(_value, _children2);\n  }\n}\n\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map(function (child) {\n    var _iterator4 = _createForOfIteratorHelper(prevState.children),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var p = _step4.value;\n\n        if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n          return createNode(routeReuseStrategy, child, p);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return createNode(routeReuseStrategy, child);\n  });\n}\n\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nfunction redirectingNavigationError(urlSerializer, redirect) {\n  var _ref2 = isUrlTree(redirect) ? {\n    redirectTo: redirect,\n    navigationBehaviorOptions: undefined\n  } : redirect,\n      redirectTo = _ref2.redirectTo,\n      navigationBehaviorOptions = _ref2.navigationBehaviorOptions;\n\n  var error = navigationCancelingError(ngDevMode && \"Redirecting to \\\"\".concat(urlSerializer.serialize(redirectTo), \"\\\"\"), 0\n  /* NavigationCancellationCode.Redirect */\n  , redirect);\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\n\nfunction navigationCancelingError(message, code, redirectUrl) {\n  var error = new Error('NavigationCancelingError: ' + (message || ''));\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n\n  if (redirectUrl) {\n    error.url = redirectUrl;\n  }\n\n  return error;\n}\n\nfunction isRedirectingNavigationCancelingError$1(error) {\n  return isNavigationCancelingError$1(error) && isUrlTree(error.url);\n}\n\nfunction isNavigationCancelingError$1(error) {\n  return error && error[NAVIGATION_CANCELING_ERROR];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\n\n\nvar OutletContext = /*#__PURE__*/_createClass(function OutletContext() {\n  _classCallCheck(this, OutletContext);\n\n  this.outlet = null;\n  this.route = null;\n  /**\n   * @deprecated Passing a resolver to retrieve a component factory is not required and is\n   *     deprecated since v14.\n   */\n\n  this.resolver = null;\n  this.injector = null;\n  this.children = new ChildrenOutletContexts();\n  this.attachRef = null;\n});\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\n\n\nvar ChildrenOutletContexts = /*#__PURE__*/(function () {\n  var ChildrenOutletContexts = /*#__PURE__*/function () {\n    function ChildrenOutletContexts() {\n      _classCallCheck(this, ChildrenOutletContexts);\n\n      // contexts for child outlets, by name.\n      this.contexts = new Map();\n    }\n    /** Called when a `RouterOutlet` directive is instantiated */\n\n\n    _createClass(ChildrenOutletContexts, [{\n      key: \"onChildOutletCreated\",\n      value: function onChildOutletCreated(childName, outlet) {\n        var context = this.getOrCreateContext(childName);\n        context.outlet = outlet;\n        this.contexts.set(childName, context);\n      }\n      /**\n       * Called when a `RouterOutlet` directive is destroyed.\n       * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n       * re-created later.\n       */\n\n    }, {\n      key: \"onChildOutletDestroyed\",\n      value: function onChildOutletDestroyed(childName) {\n        var context = this.getContext(childName);\n\n        if (context) {\n          context.outlet = null;\n          context.attachRef = null;\n        }\n      }\n      /**\n       * Called when the corresponding route is deactivated during navigation.\n       * Because the component get destroyed, all children outlet are destroyed.\n       */\n\n    }, {\n      key: \"onOutletDeactivated\",\n      value: function onOutletDeactivated() {\n        var contexts = this.contexts;\n        this.contexts = new Map();\n        return contexts;\n      }\n    }, {\n      key: \"onOutletReAttached\",\n      value: function onOutletReAttached(contexts) {\n        this.contexts = contexts;\n      }\n    }, {\n      key: \"getOrCreateContext\",\n      value: function getOrCreateContext(childName) {\n        var context = this.getContext(childName);\n\n        if (!context) {\n          context = new OutletContext();\n          this.contexts.set(childName, context);\n        }\n\n        return context;\n      }\n    }, {\n      key: \"getContext\",\n      value: function getContext(childName) {\n        return this.contexts.get(childName) || null;\n      }\n    }]);\n\n    return ChildrenOutletContexts;\n  }();\n\n  ChildrenOutletContexts.ɵfac = function ChildrenOutletContexts_Factory(t) {\n    return new (t || ChildrenOutletContexts)();\n  };\n\n  ChildrenOutletContexts.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ChildrenOutletContexts,\n    factory: ChildrenOutletContexts.ɵfac,\n    providedIn: 'root'\n  });\n  return ChildrenOutletContexts;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$7 = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see [Routing tutorial](guide/router-tutorial-toh#named-outlets \"Example of a named\n * outlet and secondary route configuration\").\n * @see `RouterLink`\n * @see `Route`\n * @ngModule RouterModule\n *\n * @publicApi\n */\n\nvar RouterOutlet = /*#__PURE__*/(function () {\n  var RouterOutlet = /*#__PURE__*/function () {\n    function RouterOutlet(parentContexts, location, name, changeDetector, environmentInjector) {\n      _classCallCheck(this, RouterOutlet);\n\n      this.parentContexts = parentContexts;\n      this.location = location;\n      this.changeDetector = changeDetector;\n      this.environmentInjector = environmentInjector;\n      this.activated = null;\n      this._activatedRoute = null;\n      this.activateEvents = new EventEmitter();\n      this.deactivateEvents = new EventEmitter();\n      /**\n       * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n       * previously detached subtree.\n       **/\n\n      this.attachEvents = new EventEmitter();\n      /**\n       * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n       * subtree.\n       */\n\n      this.detachEvents = new EventEmitter();\n      this.name = name || PRIMARY_OUTLET;\n      parentContexts.onChildOutletCreated(this.name, this);\n    }\n    /** @nodoc */\n\n\n    _createClass(RouterOutlet, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var _a; // Ensure that the registered outlet is this one before removing it on the context.\n\n\n        if (((_a = this.parentContexts.getContext(this.name)) === null || _a === void 0 ? void 0 : _a.outlet) === this) {\n          this.parentContexts.onChildOutletDestroyed(this.name);\n        }\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (!this.activated) {\n          // If the outlet was not instantiated at the time the route got activated we need to populate\n          // the outlet when it is initialized (ie inside a NgIf)\n          var context = this.parentContexts.getContext(this.name);\n\n          if (context && context.route) {\n            if (context.attachRef) {\n              // `attachRef` is populated when there is an existing component to mount\n              this.attach(context.attachRef, context.route);\n            } else {\n              // otherwise the component defined in the configuration is created\n              this.activateWith(context.route, context.injector);\n            }\n          }\n        }\n      }\n    }, {\n      key: \"isActivated\",\n      get: function get() {\n        return !!this.activated;\n      }\n      /**\n       * @returns The currently activated component instance.\n       * @throws An error if the outlet is not activated.\n       */\n\n    }, {\n      key: \"component\",\n      get: function get() {\n        if (!this.activated) throw new ɵRuntimeError(4012\n        /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */\n        , NG_DEV_MODE$7 && 'Outlet is not activated');\n        return this.activated.instance;\n      }\n    }, {\n      key: \"activatedRoute\",\n      get: function get() {\n        if (!this.activated) throw new ɵRuntimeError(4012\n        /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */\n        , NG_DEV_MODE$7 && 'Outlet is not activated');\n        return this._activatedRoute;\n      }\n    }, {\n      key: \"activatedRouteData\",\n      get: function get() {\n        if (this._activatedRoute) {\n          return this._activatedRoute.snapshot.data;\n        }\n\n        return {};\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to detach the subtree\n       */\n\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        if (!this.activated) throw new ɵRuntimeError(4012\n        /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */\n        , NG_DEV_MODE$7 && 'Outlet is not activated');\n        this.location.detach();\n        var cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.detachEvents.emit(cmp.instance);\n        return cmp;\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n       */\n\n    }, {\n      key: \"attach\",\n      value: function attach(ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n        this.attachEvents.emit(ref.instance);\n      }\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        if (this.activated) {\n          var c = this.component;\n          this.activated.destroy();\n          this.activated = null;\n          this._activatedRoute = null;\n          this.deactivateEvents.emit(c);\n        }\n      }\n    }, {\n      key: \"activateWith\",\n      value: function activateWith(activatedRoute, resolverOrInjector) {\n        if (this.isActivated) {\n          throw new ɵRuntimeError(4013\n          /* RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED */\n          , NG_DEV_MODE$7 && 'Cannot activate an already activated outlet');\n        }\n\n        this._activatedRoute = activatedRoute;\n        var location = this.location;\n        var snapshot = activatedRoute._futureSnapshot;\n        var component = snapshot.component;\n        var childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        var injector = new OutletInjector(activatedRoute, childContexts, location.injector);\n\n        if (resolverOrInjector && isComponentFactoryResolver(resolverOrInjector)) {\n          var factory = resolverOrInjector.resolveComponentFactory(component);\n          this.activated = location.createComponent(factory, location.length, injector);\n        } else {\n          var environmentInjector = resolverOrInjector !== null && resolverOrInjector !== void 0 ? resolverOrInjector : this.environmentInjector;\n          this.activated = location.createComponent(component, {\n            index: location.length,\n            injector: injector,\n            environmentInjector: environmentInjector\n          });\n        } // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n\n\n        this.changeDetector.markForCheck();\n        this.activateEvents.emit(this.activated.instance);\n      }\n    }]);\n\n    return RouterOutlet;\n  }();\n\n  RouterOutlet.ɵfac = function RouterOutlet_Factory(t) {\n    return new (t || RouterOutlet)(i0.ɵɵdirectiveInject(ChildrenOutletContexts), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵinjectAttribute('name'), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.EnvironmentInjector));\n  };\n\n  RouterOutlet.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterOutlet,\n    selectors: [[\"router-outlet\"]],\n    outputs: {\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\",\n      attachEvents: \"attach\",\n      detachEvents: \"detach\"\n    },\n    exportAs: [\"outlet\"],\n    standalone: true\n  });\n  return RouterOutlet;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar OutletInjector = /*#__PURE__*/function () {\n  function OutletInjector(route, childContexts, parent) {\n    _classCallCheck(this, OutletInjector);\n\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n\n  _createClass(OutletInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      if (token === ActivatedRoute) {\n        return this.route;\n      }\n\n      if (token === ChildrenOutletContexts) {\n        return this.childContexts;\n      }\n\n      return this.parent.get(token, notFoundValue);\n    }\n  }]);\n\n  return OutletInjector;\n}();\n\nfunction isComponentFactoryResolver(item) {\n  return !!item.resolveComponentFactory;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n\n\nvar ɵEmptyOutletComponent = /*#__PURE__*/(function () {\n  var ɵEmptyOutletComponent = /*#__PURE__*/_createClass(function ɵEmptyOutletComponent() {\n    _classCallCheck(this, ɵEmptyOutletComponent);\n  });\n\n  ɵEmptyOutletComponent.ɵfac = function ɵEmptyOutletComponent_Factory(t) {\n    return new (t || ɵEmptyOutletComponent)();\n  };\n\n  ɵEmptyOutletComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ɵEmptyOutletComponent,\n    selectors: [[\"ng-component\"]],\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 0,\n    template: function ɵEmptyOutletComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"router-outlet\");\n      }\n    },\n    dependencies: [RouterOutlet],\n    encapsulation: 2\n  });\n  return ɵEmptyOutletComponent;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\n\n\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\n  var _a;\n\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(route.providers, currentInjector, \"Route: \".concat(route.path));\n  }\n\n  return (_a = route._injector) !== null && _a !== void 0 ? _a : currentInjector;\n}\n\nfunction getLoadedRoutes(route) {\n  return route._loadedRoutes;\n}\n\nfunction getLoadedInjector(route) {\n  return route._loadedInjector;\n}\n\nfunction getLoadedComponent(route) {\n  return route._loadedComponent;\n}\n\nfunction getProvidersInjector(route) {\n  return route._injector;\n}\n\nfunction validateConfig(config) {\n  var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var requireStandaloneComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // forEach doesn't iterate undefined values\n  for (var i = 0; i < config.length; i++) {\n    var route = config[i];\n    var fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\n\nfunction assertStandalone(fullPath, component) {\n  if (component && !ɵisStandalone(component)) {\n    throw new ɵRuntimeError(4014\n    /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n    , \"Invalid configuration of route '\".concat(fullPath, \"'. The component must be standalone.\"));\n  }\n}\n\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"\\n      Invalid configuration of route '\".concat(fullPath, \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n\\n      Example:\\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \"));\n    }\n\n    if (Array.isArray(route)) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': Array cannot be specified\"));\n    }\n\n    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': a componentless route without children or loadChildren cannot have a named outlet set\"));\n    }\n\n    if (route.redirectTo && route.children) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and children cannot be used together\"));\n    }\n\n    if (route.redirectTo && route.loadChildren) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and loadChildren cannot be used together\"));\n    }\n\n    if (route.children && route.loadChildren) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': children and loadChildren cannot be used together\"));\n    }\n\n    if (route.redirectTo && (route.component || route.loadComponent)) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and component/loadComponent cannot be used together\"));\n    }\n\n    if (route.component && route.loadComponent) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': component and loadComponent cannot be used together\"));\n    }\n\n    if (route.redirectTo && route.canActivate) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and canActivate cannot be used together. Redirects happen before activation \") + \"so canActivate will never be executed.\");\n    }\n\n    if (route.path && route.matcher) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': path and matcher cannot be used together\"));\n    }\n\n    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren\"));\n    }\n\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': routes must have either a path or a matcher specified\"));\n    }\n\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '\".concat(fullPath, \"': path cannot start with a slash\"));\n    }\n\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n      throw new ɵRuntimeError(4014\n      /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */\n      , \"Invalid configuration of route '{path: \\\"\".concat(fullPath, \"\\\", redirectTo: \\\"\").concat(route.redirectTo, \"\\\"}': please provide 'pathMatch'. \").concat(exp));\n    }\n\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\n\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return \"\".concat(parentPath, \"/\");\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return \"\".concat(parentPath, \"/\").concat(currentRoute.path);\n  }\n}\n/**\n * Makes a copy of the config and adds any default required properties.\n */\n\n\nfunction standardizeConfig(r) {\n  var children = r.children && r.children.map(standardizeConfig);\n  var c = children ? Object.assign(Object.assign({}, r), {\n    children: children\n  }) : Object.assign({}, r);\n\n  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {\n    c.component = ɵEmptyOutletComponent;\n  }\n\n  return c;\n}\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\n\n\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\n\n\nfunction sortByMatchingOutlets(routes, outletName) {\n  var sortedConfig = routes.filter(function (r) {\n    return getOutlet(r) === outletName;\n  });\n  sortedConfig.push.apply(sortedConfig, _toConsumableArray(routes.filter(function (r) {\n    return getOutlet(r) !== outletName;\n  })));\n  return sortedConfig;\n}\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\n\n\nfunction getClosestRouteInjector(snapshot) {\n  var _a;\n\n  if (!snapshot) return null; // If the current route has its own injector, which is created from the static providers on the\n  // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n  // include the lazy loaded injector from this route.\n\n  if ((_a = snapshot.routeConfig) === null || _a === void 0 ? void 0 : _a._injector) {\n    return snapshot.routeConfig._injector;\n  }\n\n  for (var s = snapshot.parent; s; s = s.parent) {\n    var route = s.routeConfig; // Note that the order here is important. `_loadedInjector` stored on the route with\n    // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n    // is created from the static providers on that parent route, so it applies to the children as\n    // well, but only if there is no lazy loaded NgModuleRef injector.\n\n    if (route === null || route === void 0 ? void 0 : route._loadedInjector) return route._loadedInjector;\n    if (route === null || route === void 0 ? void 0 : route._injector) return route._injector;\n  }\n\n  return null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar activateRoutes = function activateRoutes(rootContexts, routeReuseStrategy, forwardEvent) {\n  return map(function (t) {\n    new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent).activate(rootContexts);\n    return t;\n  });\n};\n\nvar ActivateRoutes = /*#__PURE__*/function () {\n  function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\n    _classCallCheck(this, ActivateRoutes);\n\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n  }\n\n  _createClass(ActivateRoutes, [{\n    key: \"activate\",\n    value: function activate(parentContexts) {\n      var futureRoot = this.futureState._root;\n      var currRoot = this.currState ? this.currState._root : null;\n      this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n      advanceActivatedRoute(this.futureState.root);\n      this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    } // De-activate the child route that are not re-used for the future state\n\n  }, {\n    key: \"deactivateChildRoutes\",\n    value: function deactivateChildRoutes(futureNode, currNode, contexts) {\n      var _this13 = this;\n\n      var children = nodeChildrenAsMap(currNode); // Recurse on the routes active in the future state to de-activate deeper children\n\n      futureNode.children.forEach(function (futureChild) {\n        var childOutletName = futureChild.value.outlet;\n\n        _this13.deactivateRoutes(futureChild, children[childOutletName], contexts);\n\n        delete children[childOutletName];\n      }); // De-activate the routes that will not be re-used\n\n      forEach(children, function (v, childName) {\n        _this13.deactivateRouteAndItsChildren(v, contexts);\n      });\n    }\n  }, {\n    key: \"deactivateRoutes\",\n    value: function deactivateRoutes(futureNode, currNode, parentContext) {\n      var future = futureNode.value;\n      var curr = currNode ? currNode.value : null;\n\n      if (future === curr) {\n        // Reusing the node, check to see if the children need to be de-activated\n        if (future.component) {\n          // If we have a normal route, we need to go through an outlet.\n          var context = parentContext.getContext(future.outlet);\n\n          if (context) {\n            this.deactivateChildRoutes(futureNode, currNode, context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.deactivateChildRoutes(futureNode, currNode, parentContext);\n        }\n      } else {\n        if (curr) {\n          // Deactivate the current route which will not be re-used\n          this.deactivateRouteAndItsChildren(currNode, parentContext);\n        }\n      }\n    }\n  }, {\n    key: \"deactivateRouteAndItsChildren\",\n    value: function deactivateRouteAndItsChildren(route, parentContexts) {\n      // If there is no component, the Route is never attached to an outlet (because there is no\n      // component to attach).\n      if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n        this.detachAndStoreRouteSubtree(route, parentContexts);\n      } else {\n        this.deactivateRouteAndOutlet(route, parentContexts);\n      }\n    }\n  }, {\n    key: \"detachAndStoreRouteSubtree\",\n    value: function detachAndStoreRouteSubtree(route, parentContexts) {\n      var context = parentContexts.getContext(route.value.outlet);\n      var contexts = context && route.value.component ? context.children : parentContexts;\n      var children = nodeChildrenAsMap(route);\n\n      for (var _i2 = 0, _Object$keys2 = Object.keys(children); _i2 < _Object$keys2.length; _i2++) {\n        var childOutlet = _Object$keys2[_i2];\n        this.deactivateRouteAndItsChildren(children[childOutlet], contexts);\n      }\n\n      if (context && context.outlet) {\n        var componentRef = context.outlet.detach();\n\n        var _contexts = context.children.onOutletDeactivated();\n\n        this.routeReuseStrategy.store(route.value.snapshot, {\n          componentRef: componentRef,\n          route: route,\n          contexts: _contexts\n        });\n      }\n    }\n  }, {\n    key: \"deactivateRouteAndOutlet\",\n    value: function deactivateRouteAndOutlet(route, parentContexts) {\n      var context = parentContexts.getContext(route.value.outlet); // The context could be `null` if we are on a componentless route but there may still be\n      // children that need deactivating.\n\n      var contexts = context && route.value.component ? context.children : parentContexts;\n      var children = nodeChildrenAsMap(route);\n\n      for (var _i3 = 0, _Object$keys3 = Object.keys(children); _i3 < _Object$keys3.length; _i3++) {\n        var childOutlet = _Object$keys3[_i3];\n        this.deactivateRouteAndItsChildren(children[childOutlet], contexts);\n      }\n\n      if (context && context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate(); // Destroy the contexts for all the outlets that were in the component\n\n        context.children.onOutletDeactivated(); // Clear the information about the attached component on the context but keep the reference to\n        // the outlet.\n\n        context.attachRef = null;\n        context.resolver = null;\n        context.route = null;\n      }\n    }\n  }, {\n    key: \"activateChildRoutes\",\n    value: function activateChildRoutes(futureNode, currNode, contexts) {\n      var _this14 = this;\n\n      var children = nodeChildrenAsMap(currNode);\n      futureNode.children.forEach(function (c) {\n        _this14.activateRoutes(c, children[c.value.outlet], contexts);\n\n        _this14.forwardEvent(new ActivationEnd(c.value.snapshot));\n      });\n\n      if (futureNode.children.length) {\n        this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n      }\n    }\n  }, {\n    key: \"activateRoutes\",\n    value: function activateRoutes(futureNode, currNode, parentContexts) {\n      var _a;\n\n      var future = futureNode.value;\n      var curr = currNode ? currNode.value : null;\n      advanceActivatedRoute(future); // reusing the node\n\n      if (future === curr) {\n        if (future.component) {\n          // If we have a normal route, we need to go through an outlet.\n          var context = parentContexts.getOrCreateContext(future.outlet);\n          this.activateChildRoutes(futureNode, currNode, context.children);\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, currNode, parentContexts);\n        }\n      } else {\n        if (future.component) {\n          // if we have a normal route, we need to place the component into the outlet and recurse.\n          var _context = parentContexts.getOrCreateContext(future.outlet);\n\n          if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n            var stored = this.routeReuseStrategy.retrieve(future.snapshot);\n            this.routeReuseStrategy.store(future.snapshot, null);\n\n            _context.children.onOutletReAttached(stored.contexts);\n\n            _context.attachRef = stored.componentRef;\n            _context.route = stored.route.value;\n\n            if (_context.outlet) {\n              // Attach right away when the outlet has already been instantiated\n              // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n              _context.outlet.attach(stored.componentRef, stored.route.value);\n            }\n\n            advanceActivatedRoute(stored.route.value);\n            this.activateChildRoutes(futureNode, null, _context.children);\n          } else {\n            var injector = getClosestRouteInjector(future.snapshot);\n            var cmpFactoryResolver = (_a = injector === null || injector === void 0 ? void 0 : injector.get(ComponentFactoryResolver)) !== null && _a !== void 0 ? _a : null;\n            _context.attachRef = null;\n            _context.route = future;\n            _context.resolver = cmpFactoryResolver;\n            _context.injector = injector;\n\n            if (_context.outlet) {\n              // Activate the outlet when it has already been instantiated\n              // Otherwise it will get activated from its `ngOnInit` when instantiated\n              _context.outlet.activateWith(future, _context.injector);\n            }\n\n            this.activateChildRoutes(futureNode, null, _context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, null, parentContexts);\n        }\n      }\n    }\n  }]);\n\n  return ActivateRoutes;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar CanActivate = /*#__PURE__*/_createClass(function CanActivate(path) {\n  _classCallCheck(this, CanActivate);\n\n  this.path = path;\n  this.route = this.path[this.path.length - 1];\n});\n\nvar CanDeactivate = /*#__PURE__*/_createClass(function CanDeactivate(component, route) {\n  _classCallCheck(this, CanDeactivate);\n\n  this.component = component;\n  this.route = route;\n});\n\nfunction getAllRouteGuards(future, curr, parentContexts) {\n  var futureRoot = future._root;\n  var currRoot = curr ? curr._root : null;\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nfunction getCanActivateChild(p) {\n  var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {\n    node: p,\n    guards: canActivateChild\n  };\n}\n\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\n  var NOT_FOUND = Symbol();\n  var result = injector.get(tokenOrFunction, NOT_FOUND);\n\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !ɵisInjectable(tokenOrFunction)) {\n      // We think the token is just a function so return it as-is\n      return tokenOrFunction;\n    } else {\n      // This will throw the not found error\n      return injector.get(tokenOrFunction);\n    }\n  }\n\n  return result;\n}\n\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath) {\n  var checks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    canDeactivateChecks: [],\n    canActivateChecks: []\n  };\n  var prevChildren = nodeChildrenAsMap(currNode); // Process the children of the future route\n\n  futureNode.children.forEach(function (c) {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  }); // Process any children left from the current route (not active for the future route)\n\n  forEach(prevChildren, function (v, k) {\n    return deactivateRouteAndItsChildren(v, contexts.getContext(k), checks);\n  });\n  return checks;\n}\n\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath) {\n  var checks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    canDeactivateChecks: [],\n    canActivateChecks: []\n  };\n  var future = futureNode.value;\n  var curr = currNode ? currNode.value : null;\n  var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null; // reusing the node\n\n  if (curr && future.routeConfig === curr.routeConfig) {\n    var shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\n\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    } // If we have a component, we need to go through an outlet.\n\n\n    if (future.component) {\n      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks); // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath)); // If we have a component, we need to go through an outlet.\n\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks); // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(route, context, checks) {\n  var children = nodeChildrenAsMap(route);\n  var r = route.value;\n  forEach(children, function (node, childName) {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\n\n\nfunction isFunction(v) {\n  return typeof v === 'function';\n}\n\nfunction isBoolean(v) {\n  return typeof v === 'boolean';\n}\n\nfunction isCanLoad(guard) {\n  return guard && isFunction(guard.canLoad);\n}\n\nfunction isCanActivate(guard) {\n  return guard && isFunction(guard.canActivate);\n}\n\nfunction isCanActivateChild(guard) {\n  return guard && isFunction(guard.canActivateChild);\n}\n\nfunction isCanDeactivate(guard) {\n  return guard && isFunction(guard.canDeactivate);\n}\n\nfunction isCanMatch(guard) {\n  return guard && isFunction(guard.canMatch);\n}\n\nfunction isRedirectingNavigationCancelingError(error) {\n  return isNavigationCancelingError(error) && isUrlTree(error.url);\n}\n\nfunction isNavigationCancelingError(error) {\n  return error && error[NAVIGATION_CANCELING_ERROR];\n}\n\nfunction isEmptyError(e) {\n  return e instanceof EmptyError || (e === null || e === void 0 ? void 0 : e.name) === 'EmptyError';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar INITIAL_VALUE = /*#__PURE__*/Symbol('INITIAL_VALUE');\n\nfunction prioritizedGuardValue() {\n  return switchMap(function (obs) {\n    return combineLatest(obs.map(function (o) {\n      return o.pipe(take(1), startWith(INITIAL_VALUE));\n    })).pipe(map(function (results) {\n      var _iterator5 = _createForOfIteratorHelper(results),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var result = _step5.value;\n\n          if (result === true) {\n            // If result is true, check the next one\n            continue;\n          } else if (result === INITIAL_VALUE) {\n            // If guard has not finished, we need to stop processing.\n            return INITIAL_VALUE;\n          } else if (result === false || result instanceof UrlTree) {\n            // Result finished and was not true. Return the result.\n            // Note that we only allow false/UrlTree. Other values are considered invalid and\n            // ignored.\n            return result;\n          }\n        } // Everything resolved to true. Return true.\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return true;\n    }), filter(function (item) {\n      return item !== INITIAL_VALUE;\n    }), take(1));\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction checkGuards(injector, forwardEvent) {\n  return mergeMap(function (t) {\n    var targetSnapshot = t.targetSnapshot,\n        currentSnapshot = t.currentSnapshot,\n        _t$guards = t.guards,\n        canActivateChecks = _t$guards.canActivateChecks,\n        canDeactivateChecks = _t$guards.canDeactivateChecks;\n\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of(Object.assign(Object.assign({}, t), {\n        guardsResult: true\n      }));\n    }\n\n    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap(function (canDeactivate) {\n      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);\n    }), map(function (guardsResult) {\n      return Object.assign(Object.assign({}, t), {\n        guardsResult: guardsResult\n      });\n    }));\n  });\n}\n\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {\n  return from(checks).pipe(mergeMap(function (check) {\n    return runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector);\n  }), first(function (result) {\n    return result !== true;\n  }, true));\n}\n\nfunction runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {\n  return from(checks).pipe(concatMap(function (check) {\n    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));\n  }), first(function (result) {\n    return result !== true;\n  }, true));\n}\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\n\n\nfunction fireActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n\n  return of(true);\n}\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\n\n\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n\n  return of(true);\n}\n\nfunction runCanActivate(futureRSS, futureARS, injector) {\n  var canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n  var canActivateObservables = canActivate.map(function (canActivate) {\n    return defer(function () {\n      var _a;\n\n      var closestInjector = (_a = getClosestRouteInjector(futureARS)) !== null && _a !== void 0 ? _a : injector;\n      var guard = getTokenOrFunctionIdentity(canActivate, closestInjector);\n      var guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : closestInjector.runInContext(function () {\n        return guard(futureARS, futureRSS);\n      });\n      return wrapIntoObservable(guardVal).pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanActivateChild(futureRSS, path, injector) {\n  var futureARS = path[path.length - 1];\n  var canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(function (p) {\n    return getCanActivateChild(p);\n  }).filter(function (_) {\n    return _ !== null;\n  });\n  var canActivateChildGuardsMapped = canActivateChildGuards.map(function (d) {\n    return defer(function () {\n      var guardsMapped = d.guards.map(function (canActivateChild) {\n        var _a;\n\n        var closestInjector = (_a = getClosestRouteInjector(d.node)) !== null && _a !== void 0 ? _a : injector;\n        var guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\n        var guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : closestInjector.runInContext(function () {\n          return guard(futureARS, futureRSS);\n        });\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {\n  var canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  var canDeactivateObservables = canDeactivate.map(function (c) {\n    var _a;\n\n    var closestInjector = (_a = getClosestRouteInjector(currARS)) !== null && _a !== void 0 ? _a : injector;\n    var guard = getTokenOrFunctionIdentity(c, closestInjector);\n    var guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : closestInjector.runInContext(function () {\n      return guard(component, currARS, currRSS, futureRSS);\n    });\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanLoadGuards(injector, route, segments, urlSerializer) {\n  var canLoad = route.canLoad;\n\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n\n  var canLoadObservables = canLoad.map(function (injectionToken) {\n    var guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    var guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : injector.runInContext(function () {\n      return guard(route, segments);\n    });\n    return wrapIntoObservable(guardVal);\n  });\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n\nfunction redirectIfUrlTree(urlSerializer) {\n  return pipe(tap(function (result) {\n    if (!isUrlTree(result)) return;\n    throw redirectingNavigationError(urlSerializer, result);\n  }), map(function (result) {\n    return result === true;\n  }));\n}\n\nfunction runCanMatchGuards(injector, route, segments, urlSerializer) {\n  var canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n  var canMatchObservables = canMatch.map(function (injectionToken) {\n    var guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    var guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : injector.runInContext(function () {\n      return guard(route, segments);\n    });\n    return wrapIntoObservable(guardVal);\n  });\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar noMatch$1 = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {}\n};\n\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {\n  var result = match(segmentGroup, route, segments);\n\n  if (!result.matched) {\n    return of(result);\n  } // Only create the Route's `EnvironmentInjector` if it matches the attempted\n  // navigation\n\n\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map(function (v) {\n    return v === true ? result : Object.assign({}, noMatch$1);\n  }));\n}\n\nfunction match(segmentGroup, route, segments) {\n  var _a;\n\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return Object.assign({}, noMatch$1);\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {}\n    };\n  }\n\n  var matcher = route.matcher || defaultUrlMatcher;\n  var res = matcher(segments, segmentGroup, route);\n  if (!res) return Object.assign({}, noMatch$1);\n  var posParams = {};\n  forEach(res.posParams, function (v, k) {\n    posParams[k] = v.path;\n  });\n  var parameters = res.consumed.length > 0 ? Object.assign(Object.assign({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters: parameters,\n    positionalParamSegments: (_a = res.posParams) !== null && _a !== void 0 ? _a : {}\n  };\n}\n\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n  var relativeLinkResolution = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'corrected';\n\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    var _s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\n    _s._sourceSegment = segmentGroup;\n    _s._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s,\n      slicedSegments: []\n    };\n  }\n\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    var _s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));\n\n    _s2._sourceSegment = segmentGroup;\n    _s2._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s2,\n      slicedSegments: slicedSegments\n    };\n  }\n\n  var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  s._sourceSegment = segmentGroup;\n  s._segmentIndexShift = consumedSegments.length;\n  return {\n    segmentGroup: s,\n    slicedSegments: slicedSegments\n  };\n}\n\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {\n  var res = {};\n\n  var _iterator6 = _createForOfIteratorHelper(routes),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var r = _step6.value;\n\n      if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n        var s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n\n        if (relativeLinkResolution === 'legacy') {\n          s._segmentIndexShift = segmentGroup.segments.length;\n\n          if (typeof ngDevMode === 'undefined' || !!ngDevMode) {\n            s._segmentIndexShiftCorrected = consumedSegments.length;\n          }\n        } else {\n          s._segmentIndexShift = consumedSegments.length;\n        }\n\n        res[getOutlet(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return Object.assign(Object.assign({}, children), res);\n}\n\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n  var res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  primarySegment._sourceSegment = segmentGroup;\n  primarySegment._segmentIndexShift = consumedSegments.length;\n\n  var _iterator7 = _createForOfIteratorHelper(routes),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var r = _step7.value;\n\n      if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n        var s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n        s._segmentIndexShift = consumedSegments.length;\n        res[getOutlet(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return res;\n}\n\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n  return routes.some(function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET;\n  });\n}\n\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n  return routes.some(function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r);\n  });\n}\n\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '';\n}\n/**\n * Determines if `route` is a path match for the `rawSegment`, `segments`, and `outlet` without\n * verifying that its children are a full match for the remainder of the `rawSegment` children as\n * well.\n */\n\n\nfunction isImmediateMatch(route, rawSegment, segments, outlet) {\n  // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n  // a config like\n  // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n  // or even\n  // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n  //\n  // The exception here is when the segment outlet is for the primary outlet. This would\n  // result in a match inside the named outlet because all children there are written as primary\n  // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n  // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n  // This should only match if the url is `/(x:b)`.\n  if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n    return false;\n  }\n\n  if (route.path === '**') {\n    return true;\n  }\n\n  return match(rawSegment, route, segments).matched;\n}\n\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$6 = typeof ngDevMode === 'undefined' || ngDevMode;\n\nvar NoMatch$1 = /*#__PURE__*/_createClass(function NoMatch$1(segmentGroup) {\n  _classCallCheck(this, NoMatch$1);\n\n  this.segmentGroup = segmentGroup || null;\n});\n\nvar AbsoluteRedirect = /*#__PURE__*/_createClass(function AbsoluteRedirect(urlTree) {\n  _classCallCheck(this, AbsoluteRedirect);\n\n  this.urlTree = urlTree;\n});\n\nfunction noMatch(segmentGroup) {\n  return throwError(new NoMatch$1(segmentGroup));\n}\n\nfunction absoluteRedirect(newTree) {\n  return throwError(new AbsoluteRedirect(newTree));\n}\n\nfunction namedOutletsRedirect(redirectTo) {\n  return throwError(new ɵRuntimeError(4000\n  /* RuntimeErrorCode.NAMED_OUTLET_REDIRECT */\n  , NG_DEV_MODE$6 && \"Only absolute redirects can have named outlets. redirectTo: '\".concat(redirectTo, \"'\")));\n}\n\nfunction canLoadFails(route) {\n  return throwError(navigationCancelingError(NG_DEV_MODE$6 && \"Cannot load children because the guard of the route \\\"path: '\".concat(route.path, \"'\\\" returned false\"), 3\n  /* NavigationCancellationCode.GuardRejected */\n  ));\n}\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n */\n\n\nfunction applyRedirects$1(injector, configLoader, urlSerializer, urlTree, config) {\n  return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();\n}\n\nvar ApplyRedirects = /*#__PURE__*/function () {\n  function ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config) {\n    _classCallCheck(this, ApplyRedirects);\n\n    this.injector = injector;\n    this.configLoader = configLoader;\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n    this.config = config;\n    this.allowRedirects = true;\n  }\n\n  _createClass(ApplyRedirects, [{\n    key: \"apply\",\n    value: function apply() {\n      var _this15 = this;\n\n      var splitGroup = split(this.urlTree.root, [], [], this.config).segmentGroup; // TODO(atscott): creating a new segment removes the _sourceSegment _segmentIndexShift, which is\n      // only necessary to prevent failures in tests which assert exact object matches. The `split` is\n      // now shared between `applyRedirects` and `recognize` but only the `recognize` step needs these\n      // properties. Before the implementations were merged, the `applyRedirects` would not assign\n      // them. We should be able to remove this logic as a \"breaking change\" but should do some more\n      // investigation into the failures first.\n\n      var rootSegmentGroup = new UrlSegmentGroup(splitGroup.segments, splitGroup.children);\n      var expanded$ = this.expandSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET);\n      var urlTrees$ = expanded$.pipe(map(function (rootSegmentGroup) {\n        return _this15.createUrlTree(squashSegmentGroup(rootSegmentGroup), _this15.urlTree.queryParams, _this15.urlTree.fragment);\n      }));\n      return urlTrees$.pipe(catchError(function (e) {\n        if (e instanceof AbsoluteRedirect) {\n          // After an absolute redirect we do not apply any more redirects!\n          // If this implementation changes, update the documentation note in `redirectTo`.\n          _this15.allowRedirects = false; // we need to run matching, so we can fetch all lazy-loaded modules\n\n          return _this15.match(e.urlTree);\n        }\n\n        if (e instanceof NoMatch$1) {\n          throw _this15.noMatchError(e);\n        }\n\n        throw e;\n      }));\n    }\n  }, {\n    key: \"match\",\n    value: function match(tree) {\n      var _this16 = this;\n\n      var expanded$ = this.expandSegmentGroup(this.injector, this.config, tree.root, PRIMARY_OUTLET);\n      var mapped$ = expanded$.pipe(map(function (rootSegmentGroup) {\n        return _this16.createUrlTree(squashSegmentGroup(rootSegmentGroup), tree.queryParams, tree.fragment);\n      }));\n      return mapped$.pipe(catchError(function (e) {\n        if (e instanceof NoMatch$1) {\n          throw _this16.noMatchError(e);\n        }\n\n        throw e;\n      }));\n    }\n  }, {\n    key: \"noMatchError\",\n    value: function noMatchError(e) {\n      return new ɵRuntimeError(4002\n      /* RuntimeErrorCode.NO_MATCH */\n      , NG_DEV_MODE$6 && \"Cannot match any routes. URL Segment: '\".concat(e.segmentGroup, \"'\"));\n    }\n  }, {\n    key: \"createUrlTree\",\n    value: function createUrlTree(rootCandidate, queryParams, fragment) {\n      var root = createRoot(rootCandidate);\n      return new UrlTree(root, queryParams, fragment);\n    }\n  }, {\n    key: \"expandSegmentGroup\",\n    value: function expandSegmentGroup(injector, routes, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return this.expandChildren(injector, routes, segmentGroup).pipe(map(function (children) {\n          return new UrlSegmentGroup([], children);\n        }));\n      }\n\n      return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);\n    } // Recursively expand segment groups for all the child outlets\n\n  }, {\n    key: \"expandChildren\",\n    value: function expandChildren(injector, routes, segmentGroup) {\n      var _this17 = this;\n\n      // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n      // because an absolute redirect from the primary outlet takes precedence.\n      var childOutlets = [];\n\n      for (var _i4 = 0, _Object$keys4 = Object.keys(segmentGroup.children); _i4 < _Object$keys4.length; _i4++) {\n        var child = _Object$keys4[_i4];\n\n        if (child === 'primary') {\n          childOutlets.unshift(child);\n        } else {\n          childOutlets.push(child);\n        }\n      }\n\n      return from(childOutlets).pipe(concatMap(function (childOutlet) {\n        var child = segmentGroup.children[childOutlet]; // Sort the routes so routes with outlets that match the segment appear\n        // first, followed by routes for other outlets, which might match if they have an\n        // empty path.\n\n        var sortedRoutes = sortByMatchingOutlets(routes, childOutlet);\n        return _this17.expandSegmentGroup(injector, sortedRoutes, child, childOutlet).pipe(map(function (s) {\n          return {\n            segment: s,\n            outlet: childOutlet\n          };\n        }));\n      }), scan(function (children, expandedChild) {\n        children[expandedChild.outlet] = expandedChild.segment;\n        return children;\n      }, {}), last$1());\n    }\n  }, {\n    key: \"expandSegment\",\n    value: function expandSegment(injector, segmentGroup, routes, segments, outlet, allowRedirects) {\n      var _this18 = this;\n\n      return from(routes).pipe(concatMap(function (r) {\n        var expanded$ = _this18.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);\n\n        return expanded$.pipe(catchError(function (e) {\n          if (e instanceof NoMatch$1) {\n            return of(null);\n          }\n\n          throw e;\n        }));\n      }), first(function (s) {\n        return !!s;\n      }), catchError(function (e, _) {\n        if (isEmptyError(e)) {\n          if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new UrlSegmentGroup([], {}));\n          }\n\n          return noMatch(segmentGroup);\n        }\n\n        throw e;\n      }));\n    }\n  }, {\n    key: \"expandSegmentAgainstRoute\",\n    value: function expandSegmentAgainstRoute(injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n      if (!isImmediateMatch(route, segmentGroup, paths, outlet)) {\n        return noMatch(segmentGroup);\n      }\n\n      if (route.redirectTo === undefined) {\n        return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths, outlet);\n      }\n\n      if (allowRedirects && this.allowRedirects) {\n        return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);\n      }\n\n      return noMatch(segmentGroup);\n    }\n  }, {\n    key: \"expandSegmentAgainstRouteUsingRedirect\",\n    value: function expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet) {\n      if (route.path === '**') {\n        return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);\n      }\n\n      return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);\n    }\n  }, {\n    key: \"expandWildCardWithParamsAgainstRouteUsingRedirect\",\n    value: function expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet) {\n      var _this19 = this;\n\n      var newTree = this.applyRedirectCommands([], route.redirectTo, {});\n\n      if (route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {\n        var group = new UrlSegmentGroup(newSegments, {});\n        return _this19.expandSegment(injector, group, routes, newSegments, outlet, false);\n      }));\n    }\n  }, {\n    key: \"expandRegularSegmentAgainstRouteUsingRedirect\",\n    value: function expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet) {\n      var _this20 = this;\n\n      var _match = match(segmentGroup, route, segments),\n          matched = _match.matched,\n          consumedSegments = _match.consumedSegments,\n          remainingSegments = _match.remainingSegments,\n          positionalParamSegments = _match.positionalParamSegments;\n\n      if (!matched) return noMatch(segmentGroup);\n      var newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);\n\n      if (route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {\n        return _this20.expandSegment(injector, segmentGroup, routes, newSegments.concat(remainingSegments), outlet, false);\n      }));\n    }\n  }, {\n    key: \"matchSegmentAgainstRoute\",\n    value: function matchSegmentAgainstRoute(injector, rawSegmentGroup, route, segments, outlet) {\n      var _this21 = this;\n\n      if (route.path === '**') {\n        // Only create the Route's `EnvironmentInjector` if it matches the attempted navigation\n        injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n\n        if (route.loadChildren) {\n          var loaded$ = route._loadedRoutes ? of({\n            routes: route._loadedRoutes,\n            injector: route._loadedInjector\n          }) : this.configLoader.loadChildren(injector, route);\n          return loaded$.pipe(map(function (cfg) {\n            route._loadedRoutes = cfg.routes;\n            route._loadedInjector = cfg.injector;\n            return new UrlSegmentGroup(segments, {});\n          }));\n        }\n\n        return of(new UrlSegmentGroup(segments, {}));\n      }\n\n      return matchWithChecks(rawSegmentGroup, route, segments, injector, this.urlSerializer).pipe(switchMap(function (_ref3) {\n        var matched = _ref3.matched,\n            consumedSegments = _ref3.consumedSegments,\n            remainingSegments = _ref3.remainingSegments;\n\n        var _a;\n\n        if (!matched) return noMatch(rawSegmentGroup); // If the route has an injector created from providers, we should start using that.\n\n        injector = (_a = route._injector) !== null && _a !== void 0 ? _a : injector;\n\n        var childConfig$ = _this21.getChildConfig(injector, route, segments);\n\n        return childConfig$.pipe(mergeMap(function (routerConfig) {\n          var _a;\n\n          var childInjector = (_a = routerConfig.injector) !== null && _a !== void 0 ? _a : injector;\n          var childConfig = routerConfig.routes;\n\n          var _split = split(rawSegmentGroup, consumedSegments, remainingSegments, childConfig),\n              splitSegmentGroup = _split.segmentGroup,\n              slicedSegments = _split.slicedSegments; // See comment on the other call to `split` about why this is necessary.\n\n\n          var segmentGroup = new UrlSegmentGroup(splitSegmentGroup.segments, splitSegmentGroup.children);\n\n          if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n            var _expanded$ = _this21.expandChildren(childInjector, childConfig, segmentGroup);\n\n            return _expanded$.pipe(map(function (children) {\n              return new UrlSegmentGroup(consumedSegments, children);\n            }));\n          }\n\n          if (childConfig.length === 0 && slicedSegments.length === 0) {\n            return of(new UrlSegmentGroup(consumedSegments, {}));\n          }\n\n          var matchedOnOutlet = getOutlet(route) === outlet;\n\n          var expanded$ = _this21.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true);\n\n          return expanded$.pipe(map(function (cs) {\n            return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\n          }));\n        }));\n      }));\n    }\n  }, {\n    key: \"getChildConfig\",\n    value: function getChildConfig(injector, route, segments) {\n      var _this22 = this;\n\n      if (route.children) {\n        // The children belong to the same module\n        return of({\n          routes: route.children,\n          injector: injector\n        });\n      }\n\n      if (route.loadChildren) {\n        // lazy children belong to the loaded module\n        if (route._loadedRoutes !== undefined) {\n          return of({\n            routes: route._loadedRoutes,\n            injector: route._loadedInjector\n          });\n        }\n\n        return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap(function (shouldLoadResult) {\n          if (shouldLoadResult) {\n            return _this22.configLoader.loadChildren(injector, route).pipe(tap(function (cfg) {\n              route._loadedRoutes = cfg.routes;\n              route._loadedInjector = cfg.injector;\n            }));\n          }\n\n          return canLoadFails(route);\n        }));\n      }\n\n      return of({\n        routes: [],\n        injector: injector\n      });\n    }\n  }, {\n    key: \"lineralizeSegments\",\n    value: function lineralizeSegments(route, urlTree) {\n      var res = [];\n      var c = urlTree.root;\n\n      while (true) {\n        res = res.concat(c.segments);\n\n        if (c.numberOfChildren === 0) {\n          return of(res);\n        }\n\n        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n          return namedOutletsRedirect(route.redirectTo);\n        }\n\n        c = c.children[PRIMARY_OUTLET];\n      }\n    }\n  }, {\n    key: \"applyRedirectCommands\",\n    value: function applyRedirectCommands(segments, redirectTo, posParams) {\n      return this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    }\n  }, {\n    key: \"applyRedirectCreateUrlTree\",\n    value: function applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n      var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n      return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    }\n  }, {\n    key: \"createQueryParams\",\n    value: function createQueryParams(redirectToParams, actualParams) {\n      var res = {};\n      forEach(redirectToParams, function (v, k) {\n        var copySourceValue = typeof v === 'string' && v.startsWith(':');\n\n        if (copySourceValue) {\n          var sourceName = v.substring(1);\n          res[k] = actualParams[sourceName];\n        } else {\n          res[k] = v;\n        }\n      });\n      return res;\n    }\n  }, {\n    key: \"createSegmentGroup\",\n    value: function createSegmentGroup(redirectTo, group, segments, posParams) {\n      var _this23 = this;\n\n      var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n      var children = {};\n      forEach(group.children, function (child, name) {\n        children[name] = _this23.createSegmentGroup(redirectTo, child, segments, posParams);\n      });\n      return new UrlSegmentGroup(updatedSegments, children);\n    }\n  }, {\n    key: \"createSegments\",\n    value: function createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n      var _this24 = this;\n\n      return redirectToSegments.map(function (s) {\n        return s.path.startsWith(':') ? _this24.findPosParam(redirectTo, s, posParams) : _this24.findOrReturn(s, actualSegments);\n      });\n    }\n  }, {\n    key: \"findPosParam\",\n    value: function findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n      var pos = posParams[redirectToUrlSegment.path.substring(1)];\n      if (!pos) throw new ɵRuntimeError(4001\n      /* RuntimeErrorCode.MISSING_REDIRECT */\n      , NG_DEV_MODE$6 && \"Cannot redirect to '\".concat(redirectTo, \"'. Cannot find '\").concat(redirectToUrlSegment.path, \"'.\"));\n      return pos;\n    }\n  }, {\n    key: \"findOrReturn\",\n    value: function findOrReturn(redirectToUrlSegment, actualSegments) {\n      var idx = 0;\n\n      var _iterator8 = _createForOfIteratorHelper(actualSegments),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var s = _step8.value;\n\n          if (s.path === redirectToUrlSegment.path) {\n            actualSegments.splice(idx);\n            return s;\n          }\n\n          idx++;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return redirectToUrlSegment;\n    }\n  }]);\n\n  return ApplyRedirects;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction applyRedirects(environmentInjector, configLoader, urlSerializer, config) {\n  return switchMap(function (t) {\n    return applyRedirects$1(environmentInjector, configLoader, urlSerializer, t.extractedUrl, config).pipe(map(function (urlAfterRedirects) {\n      return Object.assign(Object.assign({}, t), {\n        urlAfterRedirects: urlAfterRedirects\n      });\n    }));\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$5 = typeof ngDevMode === 'undefined' || !!ngDevMode;\n\nvar NoMatch = /*#__PURE__*/_createClass(function NoMatch() {\n  _classCallCheck(this, NoMatch);\n});\n\nfunction newObservableError(e) {\n  // TODO(atscott): This pattern is used throughout the router code and can be `throwError` instead.\n  return new Observable(function (obs) {\n    return obs.error(e);\n  });\n}\n\nfunction recognize$1(injector, rootComponentType, config, urlTree, url, urlSerializer) {\n  var paramsInheritanceStrategy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'emptyOnly';\n  var relativeLinkResolution = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'legacy';\n  return new Recognizer(injector, rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution, urlSerializer).recognize().pipe(switchMap(function (result) {\n    if (result === null) {\n      return newObservableError(new NoMatch());\n    } else {\n      return of(result);\n    }\n  }));\n}\n\nvar Recognizer = /*#__PURE__*/function () {\n  function Recognizer(injector, rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution, urlSerializer) {\n    _classCallCheck(this, Recognizer);\n\n    this.injector = injector;\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.url = url;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.relativeLinkResolution = relativeLinkResolution;\n    this.urlSerializer = urlSerializer;\n  }\n\n  _createClass(Recognizer, [{\n    key: \"recognize\",\n    value: function recognize() {\n      var _this25 = this;\n\n      var rootSegmentGroup = split(this.urlTree.root, [], [], this.config.filter(function (c) {\n        return c.redirectTo === undefined;\n      }), this.relativeLinkResolution).segmentGroup;\n      return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET).pipe(map(function (children) {\n        if (children === null) {\n          return null;\n        } // Use Object.freeze to prevent readers of the Router state from modifying it outside of a\n        // navigation, resulting in the router being out of sync with the browser.\n\n\n        var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(Object.assign({}, _this25.urlTree.queryParams)), _this25.urlTree.fragment, {}, PRIMARY_OUTLET, _this25.rootComponentType, null, _this25.urlTree.root, -1, {});\n        var rootNode = new TreeNode(root, children);\n        var routeState = new RouterStateSnapshot(_this25.url, rootNode);\n\n        _this25.inheritParamsAndData(routeState._root);\n\n        return routeState;\n      }));\n    }\n  }, {\n    key: \"inheritParamsAndData\",\n    value: function inheritParamsAndData(routeNode) {\n      var _this26 = this;\n\n      var route = routeNode.value;\n      var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\n      route.params = Object.freeze(i.params);\n      route.data = Object.freeze(i.data);\n      routeNode.children.forEach(function (n) {\n        return _this26.inheritParamsAndData(n);\n      });\n    }\n  }, {\n    key: \"processSegmentGroup\",\n    value: function processSegmentGroup(injector, config, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return this.processChildren(injector, config, segmentGroup);\n      }\n\n      return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet);\n    }\n    /**\n     * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n     * we cannot find a match for _any_ of the children.\n     *\n     * @param config - The `Routes` to match against\n     * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n     *     config.\n     */\n\n  }, {\n    key: \"processChildren\",\n    value: function processChildren(injector, config, segmentGroup) {\n      var _this27 = this;\n\n      return from(Object.keys(segmentGroup.children)).pipe(concatMap(function (childOutlet) {\n        var child = segmentGroup.children[childOutlet]; // Sort the config so that routes with outlets that match the one being activated\n        // appear first, followed by routes for other outlets, which might match if they have\n        // an empty path.\n\n        var sortedConfig = sortByMatchingOutlets(config, childOutlet);\n        return _this27.processSegmentGroup(injector, sortedConfig, child, childOutlet);\n      }), scan(function (children, outletChildren) {\n        if (!children || !outletChildren) return null;\n        children.push.apply(children, _toConsumableArray(outletChildren));\n        return children;\n      }), takeWhile(function (children) {\n        return children !== null;\n      }), defaultIfEmpty(null), last$1(), map(function (children) {\n        if (children === null) return null; // Because we may have matched two outlets to the same empty path segment, we can have\n        // multiple activated results for the same outlet. We should merge the children of\n        // these results so the final return value is only one `TreeNode` per outlet.\n\n        var mergedChildren = mergeEmptyPathMatches(children);\n\n        if (NG_DEV_MODE$5) {\n          // This should really never happen - we are only taking the first match for each\n          // outlet and merge the empty path matches.\n          checkOutletNameUniqueness(mergedChildren);\n        }\n\n        sortActivatedRouteSnapshots(mergedChildren);\n        return mergedChildren;\n      }));\n    }\n  }, {\n    key: \"processSegment\",\n    value: function processSegment(injector, routes, segmentGroup, segments, outlet) {\n      var _this28 = this;\n\n      return from(routes).pipe(concatMap(function (r) {\n        var _a;\n\n        return _this28.processSegmentAgainstRoute((_a = r._injector) !== null && _a !== void 0 ? _a : injector, r, segmentGroup, segments, outlet);\n      }), first(function (x) {\n        return !!x;\n      }), catchError(function (e) {\n        if (isEmptyError(e)) {\n          if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of([]);\n          }\n\n          return of(null);\n        }\n\n        throw e;\n      }));\n    }\n  }, {\n    key: \"processSegmentAgainstRoute\",\n    value: function processSegmentAgainstRoute(injector, route, rawSegment, segments, outlet) {\n      var _this29 = this;\n\n      var _a, _b;\n\n      if (route.redirectTo || !isImmediateMatch(route, rawSegment, segments, outlet)) return of(null);\n      var matchResult;\n\n      if (route.path === '**') {\n        var params = segments.length > 0 ? last(segments).parameters : {};\n        var pathIndexShift = getPathIndexShift(rawSegment) + segments.length;\n        var snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), (_b = (_a = route.component) !== null && _a !== void 0 ? _a : route._loadedComponent) !== null && _b !== void 0 ? _b : null, route, getSourceSegmentGroup(rawSegment), pathIndexShift, getResolve(route), // NG_DEV_MODE is used to prevent the getCorrectedPathIndexShift function from affecting\n        // production bundle size. This value is intended only to surface a warning to users\n        // depending on `relativeLinkResolution: 'legacy'` in dev mode.\n        NG_DEV_MODE$5 ? getCorrectedPathIndexShift(rawSegment) + segments.length : pathIndexShift);\n        matchResult = of({\n          snapshot: snapshot,\n          consumedSegments: [],\n          remainingSegments: []\n        });\n      } else {\n        matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer).pipe(map(function (_ref4) {\n          var matched = _ref4.matched,\n              consumedSegments = _ref4.consumedSegments,\n              remainingSegments = _ref4.remainingSegments,\n              parameters = _ref4.parameters;\n\n          var _a, _b;\n\n          if (!matched) {\n            return null;\n          }\n\n          var pathIndexShift = getPathIndexShift(rawSegment) + consumedSegments.length;\n          var snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(Object.assign({}, _this29.urlTree.queryParams)), _this29.urlTree.fragment, getData(route), getOutlet(route), (_b = (_a = route.component) !== null && _a !== void 0 ? _a : route._loadedComponent) !== null && _b !== void 0 ? _b : null, route, getSourceSegmentGroup(rawSegment), pathIndexShift, getResolve(route), NG_DEV_MODE$5 ? getCorrectedPathIndexShift(rawSegment) + consumedSegments.length : pathIndexShift);\n          return {\n            snapshot: snapshot,\n            consumedSegments: consumedSegments,\n            remainingSegments: remainingSegments\n          };\n        }));\n      }\n\n      return matchResult.pipe(switchMap(function (result) {\n        var _a, _b;\n\n        if (result === null) {\n          return of(null);\n        }\n\n        var snapshot = result.snapshot,\n            consumedSegments = result.consumedSegments,\n            remainingSegments = result.remainingSegments; // If the route has an injector created from providers, we should start using that.\n\n        injector = (_a = route._injector) !== null && _a !== void 0 ? _a : injector;\n        var childInjector = (_b = route._loadedInjector) !== null && _b !== void 0 ? _b : injector;\n        var childConfig = getChildConfig(route);\n\n        var _split2 = split(rawSegment, consumedSegments, remainingSegments, // Filter out routes with redirectTo because we are trying to create activated route\n        // snapshots and don't handle redirects here. That should have been done in\n        // `applyRedirects`.\n        childConfig.filter(function (c) {\n          return c.redirectTo === undefined;\n        }), _this29.relativeLinkResolution),\n            segmentGroup = _split2.segmentGroup,\n            slicedSegments = _split2.slicedSegments;\n\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n          return _this29.processChildren(childInjector, childConfig, segmentGroup).pipe(map(function (children) {\n            if (children === null) {\n              return null;\n            }\n\n            return [new TreeNode(snapshot, children)];\n          }));\n        }\n\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n          return of([new TreeNode(snapshot, [])]);\n        }\n\n        var matchedOnOutlet = getOutlet(route) === outlet; // If we matched a config due to empty path match on a different outlet, we need to\n        // continue passing the current outlet for the segment rather than switch to PRIMARY.\n        // Note that we switch to primary when we have a match because outlet configs look like\n        // this: {path: 'a', outlet: 'a', children: [\n        //  {path: 'b', component: B},\n        //  {path: 'c', component: C},\n        // ]}\n        // Notice that the children of the named outlet are configured with the primary outlet\n\n        return _this29.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet).pipe(map(function (children) {\n          if (children === null) {\n            return null;\n          }\n\n          return [new TreeNode(snapshot, children)];\n        }));\n      }));\n    }\n  }]);\n\n  return Recognizer;\n}();\n\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort(function (a, b) {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction getChildConfig(route) {\n  if (route.children) {\n    return route.children;\n  }\n\n  if (route.loadChildren) {\n    return route._loadedRoutes;\n  }\n\n  return [];\n}\n\nfunction hasEmptyPathConfig(node) {\n  var config = node.value.routeConfig;\n  return config && config.path === '' && config.redirectTo === undefined;\n}\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\n\n\nfunction mergeEmptyPathMatches(nodes) {\n  var result = []; // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n\n  var mergedNodes = new Set();\n\n  var _iterator9 = _createForOfIteratorHelper(nodes),\n      _step9;\n\n  try {\n    var _loop = function _loop() {\n      var node = _step9.value;\n\n      if (!hasEmptyPathConfig(node)) {\n        result.push(node);\n        return \"continue\";\n      }\n\n      var duplicateEmptyPathNode = result.find(function (resultNode) {\n        return node.value.routeConfig === resultNode.value.routeConfig;\n      });\n\n      if (duplicateEmptyPathNode !== undefined) {\n        var _duplicateEmptyPathNo;\n\n        (_duplicateEmptyPathNo = duplicateEmptyPathNode.children).push.apply(_duplicateEmptyPathNo, _toConsumableArray(node.children));\n\n        mergedNodes.add(duplicateEmptyPathNode);\n      } else {\n        result.push(node);\n      }\n    };\n\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    } // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n    // by also merging those children. This is necessary when there are multiple empty path configs\n    // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n    // if any of those children can be combined into a single node as well.\n\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  var _iterator10 = _createForOfIteratorHelper(mergedNodes),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var mergedNode = _step10.value;\n      var mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n      result.push(new TreeNode(mergedNode.value, mergedChildren));\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return result.filter(function (n) {\n    return !mergedNodes.has(n);\n  });\n}\n\nfunction checkOutletNameUniqueness(nodes) {\n  var names = {};\n  nodes.forEach(function (n) {\n    var routeWithSameOutletName = names[n.value.outlet];\n\n    if (routeWithSameOutletName) {\n      var p = routeWithSameOutletName.url.map(function (s) {\n        return s.toString();\n      }).join('/');\n      var c = n.value.url.map(function (s) {\n        return s.toString();\n      }).join('/');\n      throw new ɵRuntimeError(4006\n      /* RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET */\n      , NG_DEV_MODE$5 && \"Two segments cannot have the same outlet name: '\".concat(p, \"' and '\").concat(c, \"'.\"));\n    }\n\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getSourceSegmentGroup(segmentGroup) {\n  var s = segmentGroup;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n  }\n\n  return s;\n}\n\nfunction getPathIndexShift(segmentGroup) {\n  var _a, _b;\n\n  var s = segmentGroup;\n  var res = (_a = s._segmentIndexShift) !== null && _a !== void 0 ? _a : 0;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += (_b = s._segmentIndexShift) !== null && _b !== void 0 ? _b : 0;\n  }\n\n  return res - 1;\n}\n\nfunction getCorrectedPathIndexShift(segmentGroup) {\n  var _a, _b, _c, _d;\n\n  var s = segmentGroup;\n  var res = (_b = (_a = s._segmentIndexShiftCorrected) !== null && _a !== void 0 ? _a : s._segmentIndexShift) !== null && _b !== void 0 ? _b : 0;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += (_d = (_c = s._segmentIndexShiftCorrected) !== null && _c !== void 0 ? _c : s._segmentIndexShift) !== null && _d !== void 0 ? _d : 0;\n  }\n\n  return res - 1;\n}\n\nfunction getData(route) {\n  return route.data || {};\n}\n\nfunction getResolve(route) {\n  return route.resolve || {};\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction recognize(injector, rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {\n  return mergeMap(function (t) {\n    return recognize$1(injector, rootComponentType, config, t.urlAfterRedirects, serializer.serialize(t.urlAfterRedirects), serializer, paramsInheritanceStrategy, relativeLinkResolution).pipe(map(function (targetSnapshot) {\n      return Object.assign(Object.assign({}, t), {\n        targetSnapshot: targetSnapshot\n      });\n    }));\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction resolveData(paramsInheritanceStrategy, injector) {\n  return mergeMap(function (t) {\n    var targetSnapshot = t.targetSnapshot,\n        canActivateChecks = t.guards.canActivateChecks;\n\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n\n    var canActivateChecksResolved = 0;\n    return from(canActivateChecks).pipe(concatMap(function (check) {\n      return runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, injector);\n    }), tap(function () {\n      return canActivateChecksResolved++;\n    }), takeLast(1), mergeMap(function (_) {\n      return canActivateChecksResolved === canActivateChecks.length ? of(t) : EMPTY;\n    }));\n  });\n}\n\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {\n  var config = futureARS.routeConfig;\n  var resolve = futureARS._resolve;\n\n  if ((config === null || config === void 0 ? void 0 : config.title) !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n\n  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map(function (resolvedData) {\n    futureARS._resolvedData = resolvedData;\n    futureARS.data = inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve;\n\n    if (config && hasStaticTitle(config)) {\n      futureARS.data[RouteTitleKey] = config.title;\n    }\n\n    return null;\n  }));\n}\n\nfunction resolveNode(resolve, futureARS, futureRSS, injector) {\n  var keys = getDataKeys(resolve);\n\n  if (keys.length === 0) {\n    return of({});\n  }\n\n  var data = {};\n  return from(keys).pipe(mergeMap(function (key) {\n    return getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap(function (value) {\n      data[key] = value;\n    }));\n  }), takeLast(1), mapTo(data), catchError(function (e) {\n    return isEmptyError(e) ? EMPTY : throwError(e);\n  }));\n}\n\nfunction getDataKeys(obj) {\n  return [].concat(_toConsumableArray(Object.keys(obj)), _toConsumableArray(Object.getOwnPropertySymbols(obj)));\n}\n\nfunction getResolver(injectionToken, futureARS, futureRSS, injector) {\n  var _a;\n\n  var closestInjector = (_a = getClosestRouteInjector(futureARS)) !== null && _a !== void 0 ? _a : injector;\n  var resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  var resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : closestInjector.runInContext(function () {\n    return resolver(futureARS, futureRSS);\n  });\n  return wrapIntoObservable(resolverValue);\n}\n\nfunction hasStaticTitle(config) {\n  return typeof config.title === 'string' || config.title === null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\n\n\nfunction switchTap(next) {\n  return switchMap(function (v) {\n    var nextResult = next(v);\n\n    if (nextResult) {\n      return from(nextResult).pipe(map(function () {\n        return v;\n      }));\n    }\n\n    return of(v);\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/router#setting-the-page-title)\n */\n\n\nvar TitleStrategy = /*#__PURE__*/(function () {\n  var TitleStrategy = /*#__PURE__*/function () {\n    function TitleStrategy() {\n      _classCallCheck(this, TitleStrategy);\n    }\n\n    _createClass(TitleStrategy, [{\n      key: \"buildTitle\",\n      value:\n      /**\n       * @returns The `title` of the deepest primary route.\n       */\n      function buildTitle(snapshot) {\n        var _a;\n\n        var pageTitle;\n        var route = snapshot.root;\n\n        while (route !== undefined) {\n          pageTitle = (_a = this.getResolvedTitleForRoute(route)) !== null && _a !== void 0 ? _a : pageTitle;\n          route = route.children.find(function (child) {\n            return child.outlet === PRIMARY_OUTLET;\n          });\n        }\n\n        return pageTitle;\n      }\n      /**\n       * Given an `ActivatedRouteSnapshot`, returns the final value of the\n       * `Route.title` property, which can either be a static string or a resolved value.\n       */\n\n    }, {\n      key: \"getResolvedTitleForRoute\",\n      value: function getResolvedTitleForRoute(snapshot) {\n        return snapshot.data[RouteTitleKey];\n      }\n    }]);\n\n    return TitleStrategy;\n  }();\n\n  TitleStrategy.ɵfac = function TitleStrategy_Factory(t) {\n    return new (t || TitleStrategy)();\n  };\n\n  TitleStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TitleStrategy,\n    factory: function factory() {\n      return function () {\n        return inject(DefaultTitleStrategy);\n      }();\n    },\n    providedIn: 'root'\n  });\n  return TitleStrategy;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\n\n\nvar DefaultTitleStrategy = /*#__PURE__*/(function () {\n  var DefaultTitleStrategy = /*#__PURE__*/function (_TitleStrategy) {\n    _inherits(DefaultTitleStrategy, _TitleStrategy);\n\n    var _super12 = _createSuper(DefaultTitleStrategy);\n\n    function DefaultTitleStrategy(title) {\n      var _this30;\n\n      _classCallCheck(this, DefaultTitleStrategy);\n\n      _this30 = _super12.call(this);\n      _this30.title = title;\n      return _this30;\n    }\n    /**\n     * Sets the title of the browser to the given value.\n     *\n     * @param title The `pageTitle` from the deepest primary route.\n     */\n\n\n    _createClass(DefaultTitleStrategy, [{\n      key: \"updateTitle\",\n      value: function updateTitle(snapshot) {\n        var title = this.buildTitle(snapshot);\n\n        if (title !== undefined) {\n          this.title.setTitle(title);\n        }\n      }\n    }]);\n\n    return DefaultTitleStrategy;\n  }(TitleStrategy);\n\n  DefaultTitleStrategy.ɵfac = function DefaultTitleStrategy_Factory(t) {\n    return new (t || DefaultTitleStrategy)(i0.ɵɵinject(i1.Title));\n  };\n\n  DefaultTitleStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultTitleStrategy,\n    factory: DefaultTitleStrategy.ɵfac,\n    providedIn: 'root'\n  });\n  return DefaultTitleStrategy;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Exists to aid internal migration off of the deprecated relativeLinkResolution option.\n */\n\n\nfunction assignRelativeLinkResolution(router) {}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\n\n\nvar RouteReuseStrategy = /*#__PURE__*/_createClass(function RouteReuseStrategy() {\n  _classCallCheck(this, RouteReuseStrategy);\n});\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\n\n\nvar BaseRouteReuseStrategy = /*#__PURE__*/function () {\n  function BaseRouteReuseStrategy() {\n    _classCallCheck(this, BaseRouteReuseStrategy);\n  }\n\n  _createClass(BaseRouteReuseStrategy, [{\n    key: \"shouldDetach\",\n    value:\n    /**\n     * Whether the given route should detach for later reuse.\n     * Always returns false for `BaseRouteReuseStrategy`.\n     * */\n    function shouldDetach(route) {\n      return false;\n    }\n    /**\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(route, detachedTree) {}\n    /** Returns `false`, meaning the route (and its subtree) is never reattached */\n\n  }, {\n    key: \"shouldAttach\",\n    value: function shouldAttach(route) {\n      return false;\n    }\n    /** Returns `null` because this strategy does not store routes for later re-use. */\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(route) {\n      return null;\n    }\n    /**\n     * Determines if a route should be reused.\n     * This strategy returns `true` when the future route config and current route config are\n     * identical.\n     */\n\n  }, {\n    key: \"shouldReuseRoute\",\n    value: function shouldReuseRoute(future, curr) {\n      return future.routeConfig === curr.routeConfig;\n    }\n  }]);\n\n  return BaseRouteReuseStrategy;\n}();\n\nvar DefaultRouteReuseStrategy = /*#__PURE__*/function (_BaseRouteReuseStrate) {\n  _inherits(DefaultRouteReuseStrategy, _BaseRouteReuseStrate);\n\n  var _super13 = _createSuper(DefaultRouteReuseStrategy);\n\n  function DefaultRouteReuseStrategy() {\n    _classCallCheck(this, DefaultRouteReuseStrategy);\n\n    return _super13.apply(this, arguments);\n  }\n\n  return _createClass(DefaultRouteReuseStrategy);\n}(BaseRouteReuseStrategy);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$4 = typeof ngDevMode === 'undefined' || !!ngDevMode;\n/**\n * A [DI token](guide/glossary/#di-token) for the router service.\n *\n * @publicApi\n */\n\nvar ROUTER_CONFIGURATION = /*#__PURE__*/new InjectionToken(NG_DEV_MODE$4 ? 'router config' : '', {\n  providedIn: 'root',\n  factory: function factory() {\n    return {};\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar NG_DEV_MODE$3 = typeof ngDevMode === 'undefined' || !!ngDevMode;\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `RouterModule.forChild()`, `provideRoutes`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\n\nvar ROUTES = /*#__PURE__*/new InjectionToken('ROUTES');\nvar RouterConfigLoader = /*#__PURE__*/(function () {\n  var RouterConfigLoader = /*#__PURE__*/function () {\n    function RouterConfigLoader(injector, compiler) {\n      _classCallCheck(this, RouterConfigLoader);\n\n      this.injector = injector;\n      this.compiler = compiler;\n      this.componentLoaders = new WeakMap();\n      this.childrenLoaders = new WeakMap();\n    }\n\n    _createClass(RouterConfigLoader, [{\n      key: \"loadComponent\",\n      value: function loadComponent(route) {\n        var _this31 = this;\n\n        if (this.componentLoaders.get(route)) {\n          return this.componentLoaders.get(route);\n        } else if (route._loadedComponent) {\n          return of(route._loadedComponent);\n        }\n\n        if (this.onLoadStartListener) {\n          this.onLoadStartListener(route);\n        }\n\n        var loadRunner = wrapIntoObservable(route.loadComponent()).pipe(tap(function (component) {\n          var _a;\n\n          if (_this31.onLoadEndListener) {\n            _this31.onLoadEndListener(route);\n          }\n\n          NG_DEV_MODE$3 && assertStandalone((_a = route.path) !== null && _a !== void 0 ? _a : '', component);\n          route._loadedComponent = component;\n        }), finalize(function () {\n          _this31.componentLoaders.delete(route);\n        })); // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n\n        var loader = new ConnectableObservable(loadRunner, function () {\n          return new Subject();\n        }).pipe(refCount());\n        this.componentLoaders.set(route, loader);\n        return loader;\n      }\n    }, {\n      key: \"loadChildren\",\n      value: function loadChildren(parentInjector, route) {\n        var _this32 = this;\n\n        if (this.childrenLoaders.get(route)) {\n          return this.childrenLoaders.get(route);\n        } else if (route._loadedRoutes) {\n          return of({\n            routes: route._loadedRoutes,\n            injector: route._loadedInjector\n          });\n        }\n\n        if (this.onLoadStartListener) {\n          this.onLoadStartListener(route);\n        }\n\n        var moduleFactoryOrRoutes$ = this.loadModuleFactoryOrRoutes(route.loadChildren);\n        var loadRunner = moduleFactoryOrRoutes$.pipe(map(function (factoryOrRoutes) {\n          if (_this32.onLoadEndListener) {\n            _this32.onLoadEndListener(route);\n          } // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is no\n          // injector associated with lazy loading a `Route` array.\n\n\n          var injector;\n          var rawRoutes;\n          var requireStandaloneComponents = false;\n\n          if (Array.isArray(factoryOrRoutes)) {\n            rawRoutes = factoryOrRoutes;\n            requireStandaloneComponents = true;\n          } else {\n            injector = factoryOrRoutes.create(parentInjector).injector; // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n            // will get stuck in an infinite loop. The child module's Injector will look to\n            // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n            // for it's parent module instead.\n\n            rawRoutes = flatten(injector.get(ROUTES, [], InjectFlags.Self | InjectFlags.Optional));\n          }\n\n          var routes = rawRoutes.map(standardizeConfig);\n          NG_DEV_MODE$3 && validateConfig(routes, route.path, requireStandaloneComponents);\n          return {\n            routes: routes,\n            injector: injector\n          };\n        }), finalize(function () {\n          _this32.childrenLoaders.delete(route);\n        })); // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n\n        var loader = new ConnectableObservable(loadRunner, function () {\n          return new Subject();\n        }).pipe(refCount());\n        this.childrenLoaders.set(route, loader);\n        return loader;\n      }\n    }, {\n      key: \"loadModuleFactoryOrRoutes\",\n      value: function loadModuleFactoryOrRoutes(loadChildren) {\n        var _this33 = this;\n\n        return wrapIntoObservable(loadChildren()).pipe(mergeMap(function (t) {\n          if (t instanceof NgModuleFactory || Array.isArray(t)) {\n            return of(t);\n          } else {\n            return from(_this33.compiler.compileModuleAsync(t));\n          }\n        }));\n      }\n    }]);\n\n    return RouterConfigLoader;\n  }();\n\n  RouterConfigLoader.ɵfac = function RouterConfigLoader_Factory(t) {\n    return new (t || RouterConfigLoader)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.Compiler));\n  };\n\n  RouterConfigLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouterConfigLoader,\n    factory: RouterConfigLoader.ɵfac,\n    providedIn: 'root'\n  });\n  return RouterConfigLoader;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\n\n\nvar UrlHandlingStrategy = /*#__PURE__*/_createClass(function UrlHandlingStrategy() {\n  _classCallCheck(this, UrlHandlingStrategy);\n});\n/**\n * @publicApi\n */\n\n\nvar DefaultUrlHandlingStrategy = /*#__PURE__*/function () {\n  function DefaultUrlHandlingStrategy() {\n    _classCallCheck(this, DefaultUrlHandlingStrategy);\n  }\n\n  _createClass(DefaultUrlHandlingStrategy, [{\n    key: \"shouldProcessUrl\",\n    value: function shouldProcessUrl(url) {\n      return true;\n    }\n  }, {\n    key: \"extract\",\n    value: function extract(url) {\n      return url;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(newUrlPart, wholeUrl) {\n      return newUrlPart;\n    }\n  }]);\n\n  return DefaultUrlHandlingStrategy;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$2 = typeof ngDevMode === 'undefined' || !!ngDevMode;\n\nfunction defaultErrorHandler(error) {\n  throw error;\n}\n\nfunction defaultMalformedUriErrorHandler(error, urlSerializer, url) {\n  return urlSerializer.parse('/');\n}\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\n\n\nvar exactMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact'\n};\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\n\nvar subsetMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset'\n};\n\nfunction assignExtraOptionsToRouter(opts, router) {\n  if (opts.errorHandler) {\n    router.errorHandler = opts.errorHandler;\n  }\n\n  if (opts.malformedUriErrorHandler) {\n    router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\n  }\n\n  if (opts.onSameUrlNavigation) {\n    router.onSameUrlNavigation = opts.onSameUrlNavigation;\n  }\n\n  if (opts.paramsInheritanceStrategy) {\n    router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n  }\n\n  if (opts.relativeLinkResolution) {\n    router.relativeLinkResolution = opts.relativeLinkResolution;\n  }\n\n  if (opts.urlUpdateStrategy) {\n    router.urlUpdateStrategy = opts.urlUpdateStrategy;\n  }\n\n  if (opts.canceledNavigationResolution) {\n    router.canceledNavigationResolution = opts.canceledNavigationResolution;\n  }\n}\n\nfunction setupRouter() {\n  var _a, _b;\n\n  var urlSerializer = inject(UrlSerializer);\n  var contexts = inject(ChildrenOutletContexts);\n  var location = inject(Location);\n  var injector = inject(Injector);\n  var compiler = inject(Compiler);\n  var config = (_a = inject(ROUTES, {\n    optional: true\n  })) !== null && _a !== void 0 ? _a : [];\n  var opts = (_b = inject(ROUTER_CONFIGURATION, {\n    optional: true\n  })) !== null && _b !== void 0 ? _b : {};\n  var defaultTitleStrategy = inject(DefaultTitleStrategy);\n  var titleStrategy = inject(TitleStrategy, {\n    optional: true\n  });\n  var urlHandlingStrategy = inject(UrlHandlingStrategy, {\n    optional: true\n  });\n  var routeReuseStrategy = inject(RouteReuseStrategy, {\n    optional: true\n  });\n  var router = new Router(null, urlSerializer, contexts, location, injector, compiler, flatten(config));\n\n  if (urlHandlingStrategy) {\n    router.urlHandlingStrategy = urlHandlingStrategy;\n  }\n\n  if (routeReuseStrategy) {\n    router.routeReuseStrategy = routeReuseStrategy;\n  }\n\n  router.titleStrategy = titleStrategy !== null && titleStrategy !== void 0 ? titleStrategy : defaultTitleStrategy;\n  assignExtraOptionsToRouter(opts, router);\n  assignRelativeLinkResolution(router);\n  return router;\n}\n/**\n * @description\n *\n * A service that provides navigation among views and URL manipulation capabilities.\n *\n * @see `Route`.\n * @see [Routing and Navigation Guide](guide/router).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n\n\nvar Router = /*#__PURE__*/(function () {\n  var Router = /*#__PURE__*/function () {\n    /**\n     * Creates the router service.\n     */\n    // TODO: vsavkin make internal after the final is out.\n    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, compiler, config) {\n      var _this34 = this;\n\n      _classCallCheck(this, Router);\n\n      this.rootComponentType = rootComponentType;\n      this.urlSerializer = urlSerializer;\n      this.rootContexts = rootContexts;\n      this.location = location;\n      this.config = config;\n      this.lastSuccessfulNavigation = null;\n      this.currentNavigation = null;\n      this.disposed = false;\n      this.navigationId = 0;\n      /**\n       * The id of the currently active page in the router.\n       * Updated to the transition's target id on a successful navigation.\n       *\n       * This is used to track what page the router last activated. When an attempted navigation fails,\n       * the router can then use this to compute how to restore the state back to the previously active\n       * page.\n       */\n\n      this.currentPageId = 0;\n      this.isNgZoneEnabled = false;\n      /**\n       * An event stream for routing events in this NgModule.\n       */\n\n      this.events = new Subject();\n      /**\n       * A handler for navigation errors in this NgModule.\n       */\n\n      this.errorHandler = defaultErrorHandler;\n      /**\n       * A handler for errors thrown by `Router.parseUrl(url)`\n       * when `url` contains an invalid character.\n       * The most common case is a `%` sign\n       * that's not encoded and is not part of a percent encoded sequence.\n       */\n\n      this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;\n      /**\n       * True if at least one navigation event has occurred,\n       * false otherwise.\n       */\n\n      this.navigated = false;\n      this.lastSuccessfulId = -1;\n      /**\n       * Hook that enables you to pause navigation after the preactivation phase.\n       * Used by `RouterModule`.\n       *\n       * @internal\n       */\n\n      this.afterPreactivation = function () {\n        return of(void 0);\n      };\n      /**\n       * A strategy for extracting and merging URLs.\n       * Used for AngularJS to Angular migrations.\n       */\n\n\n      this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n      /**\n       * A strategy for re-using routes.\n       */\n\n      this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n      /**\n       * How to handle a navigation request to the current URL. One of:\n       *\n       * - `'ignore'` :  The router ignores the request.\n       * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n       *\n       * Note that this only configures whether the Route reprocesses the URL and triggers related\n       * action and events like redirects, guards, and resolvers. By default, the router re-uses a\n       * component instance when it re-navigates to the same component type without visiting a different\n       * component first. This behavior is configured by the `RouteReuseStrategy`. In order to reload\n       * routed components on same url navigation, you need to set `onSameUrlNavigation` to `'reload'`\n       * _and_ provide a `RouteReuseStrategy` which returns `false` for `shouldReuseRoute`.\n       */\n\n      this.onSameUrlNavigation = 'ignore';\n      /**\n       * How to merge parameters, data, resolved data, and title from parent to child\n       * routes. One of:\n       *\n       * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n       * for path-less or component-less routes.\n       * - `'always'` : Inherit parent parameters, data, and resolved data\n       * for all child routes.\n       */\n\n      this.paramsInheritanceStrategy = 'emptyOnly';\n      /**\n       * Determines when the router updates the browser URL.\n       * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n       * Set to `'eager'` to update the browser URL at the beginning of navigation.\n       * You can choose to update early so that, if navigation fails,\n       * you can show an error message with the URL that failed.\n       */\n\n      this.urlUpdateStrategy = 'deferred';\n      /**\n       * Enables a bug fix that corrects relative link resolution in components with empty paths.\n       * @see `RouterModule`\n       *\n       * @deprecated\n       */\n\n      this.relativeLinkResolution = 'corrected';\n      /**\n       * Configures how the Router attempts to restore state when a navigation is cancelled.\n       *\n       * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n       * router before the navigation started. This means that if the URL of the browser is updated\n       * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n       * than trying to restore to the previous location in the session history. This happens most\n       * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n       * buttons.\n       *\n       * 'computed' - Will attempt to return to the same index in the session history that corresponds\n       * to the Angular route when the navigation gets cancelled. For example, if the browser back\n       * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n       * and vice versa.\n       *\n       * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n       * handles a portion of the URL because the history restoration navigates to the previous place in\n       * the browser history rather than simply resetting a portion of the URL.\n       *\n       * The default value is `replace`.\n       *\n       */\n\n      this.canceledNavigationResolution = 'replace';\n\n      var onLoadStart = function onLoadStart(r) {\n        return _this34.triggerEvent(new RouteConfigLoadStart(r));\n      };\n\n      var onLoadEnd = function onLoadEnd(r) {\n        return _this34.triggerEvent(new RouteConfigLoadEnd(r));\n      };\n\n      this.configLoader = injector.get(RouterConfigLoader);\n      this.configLoader.onLoadEndListener = onLoadEnd;\n      this.configLoader.onLoadStartListener = onLoadStart;\n      this.ngModule = injector.get(NgModuleRef);\n      this.console = injector.get(ɵConsole);\n      var ngZone = injector.get(NgZone);\n      this.isNgZoneEnabled = ngZone instanceof NgZone && NgZone.isInAngularZone();\n      this.resetConfig(config);\n      this.currentUrlTree = createEmptyUrlTree();\n      this.rawUrlTree = this.currentUrlTree;\n      this.browserUrlTree = this.currentUrlTree;\n      this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n      this.transitions = new BehaviorSubject({\n        id: 0,\n        targetPageId: 0,\n        currentUrlTree: this.currentUrlTree,\n        currentRawUrl: this.currentUrlTree,\n        extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),\n        urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),\n        rawUrl: this.currentUrlTree,\n        extras: {},\n        resolve: null,\n        reject: null,\n        promise: Promise.resolve(true),\n        source: 'imperative',\n        restoredState: null,\n        currentSnapshot: this.routerState.snapshot,\n        targetSnapshot: null,\n        currentRouterState: this.routerState,\n        targetRouterState: null,\n        guards: {\n          canActivateChecks: [],\n          canDeactivateChecks: []\n        },\n        guardsResult: null\n      });\n      this.navigations = this.setupNavigations(this.transitions);\n      this.processNavigations();\n    }\n    /**\n     * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n     * important for computing the target page id for new navigations because we need to ensure each\n     * page id in the browser history is 1 more than the previous entry.\n     */\n\n\n    _createClass(Router, [{\n      key: \"browserPageId\",\n      get: function get() {\n        var _a;\n\n        return (_a = this.location.getState()) === null || _a === void 0 ? void 0 : _a.ɵrouterPageId;\n      }\n    }, {\n      key: \"setupNavigations\",\n      value: function setupNavigations(transitions) {\n        var _this35 = this;\n\n        var eventsSubject = this.events;\n        return transitions.pipe(filter(function (t) {\n          return t.id !== 0;\n        }), // Extract URL\n        map(function (t) {\n          return Object.assign(Object.assign({}, t), {\n            extractedUrl: _this35.urlHandlingStrategy.extract(t.rawUrl)\n          });\n        }), // Using switchMap so we cancel executing navigations when a new one comes in\n        switchMap(function (overallTransitionState) {\n          var completed = false;\n          var errored = false;\n          return of(overallTransitionState).pipe( // Store the Navigation object\n          tap(function (t) {\n            _this35.currentNavigation = {\n              id: t.id,\n              initialUrl: t.rawUrl,\n              extractedUrl: t.extractedUrl,\n              trigger: t.source,\n              extras: t.extras,\n              previousNavigation: _this35.lastSuccessfulNavigation ? Object.assign(Object.assign({}, _this35.lastSuccessfulNavigation), {\n                previousNavigation: null\n              }) : null\n            };\n          }), switchMap(function (t) {\n            var browserUrlTree = _this35.browserUrlTree.toString();\n\n            var urlTransition = !_this35.navigated || t.extractedUrl.toString() !== browserUrlTree || // Navigations which succeed or ones which fail and are cleaned up\n            // correctly should result in `browserUrlTree` and `currentUrlTree`\n            // matching. If this is not the case, assume something went wrong and\n            // try processing the URL again.\n            browserUrlTree !== _this35.currentUrlTree.toString();\n\n            var processCurrentUrl = (_this35.onSameUrlNavigation === 'reload' ? true : urlTransition) && _this35.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);\n\n            if (processCurrentUrl) {\n              // If the source of the navigation is from a browser event, the URL is\n              // already updated. We already need to sync the internal state.\n              if (isBrowserTriggeredNavigation(t.source)) {\n                _this35.browserUrlTree = t.extractedUrl;\n              }\n\n              return of(t).pipe( // Fire NavigationStart event\n              switchMap(function (t) {\n                var transition = _this35.transitions.getValue();\n\n                eventsSubject.next(new NavigationStart(t.id, _this35.serializeUrl(t.extractedUrl), t.source, t.restoredState));\n\n                if (transition !== _this35.transitions.getValue()) {\n                  return EMPTY;\n                } // This delay is required to match old behavior that forced\n                // navigation to always be async\n\n\n                return Promise.resolve(t);\n              }), // ApplyRedirects\n              applyRedirects(_this35.ngModule.injector, _this35.configLoader, _this35.urlSerializer, _this35.config), // Update the currentNavigation\n              // `urlAfterRedirects` is guaranteed to be set after this point\n              tap(function (t) {\n                _this35.currentNavigation = Object.assign(Object.assign({}, _this35.currentNavigation), {\n                  finalUrl: t.urlAfterRedirects\n                });\n                overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n              }), // Recognize\n              recognize(_this35.ngModule.injector, _this35.rootComponentType, _this35.config, _this35.urlSerializer, _this35.paramsInheritanceStrategy, _this35.relativeLinkResolution), // Update URL if in `eager` update mode\n              tap(function (t) {\n                overallTransitionState.targetSnapshot = t.targetSnapshot;\n\n                if (_this35.urlUpdateStrategy === 'eager') {\n                  if (!t.extras.skipLocationChange) {\n                    var rawUrl = _this35.urlHandlingStrategy.merge(t.urlAfterRedirects, t.rawUrl);\n\n                    _this35.setBrowserUrl(rawUrl, t);\n                  }\n\n                  _this35.browserUrlTree = t.urlAfterRedirects;\n                } // Fire RoutesRecognized\n\n\n                var routesRecognized = new RoutesRecognized(t.id, _this35.serializeUrl(t.extractedUrl), _this35.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\n                eventsSubject.next(routesRecognized);\n              }));\n            } else {\n              var processPreviousUrl = urlTransition && _this35.rawUrlTree && _this35.urlHandlingStrategy.shouldProcessUrl(_this35.rawUrlTree);\n              /* When the current URL shouldn't be processed, but the previous one\n               * was, we handle this \"error condition\" by navigating to the\n               * previously successful URL, but leaving the URL intact.*/\n\n\n              if (processPreviousUrl) {\n                var id = t.id,\n                    extractedUrl = t.extractedUrl,\n                    source = t.source,\n                    restoredState = t.restoredState,\n                    extras = t.extras;\n                var navStart = new NavigationStart(id, _this35.serializeUrl(extractedUrl), source, restoredState);\n                eventsSubject.next(navStart);\n                var targetSnapshot = createEmptyState(extractedUrl, _this35.rootComponentType).snapshot;\n                overallTransitionState = Object.assign(Object.assign({}, t), {\n                  targetSnapshot: targetSnapshot,\n                  urlAfterRedirects: extractedUrl,\n                  extras: Object.assign(Object.assign({}, extras), {\n                    skipLocationChange: false,\n                    replaceUrl: false\n                  })\n                });\n                return of(overallTransitionState);\n              } else {\n                /* When neither the current or previous URL can be processed, do\n                 * nothing other than update router's internal reference to the\n                 * current \"settled\" URL. This way the next navigation will be coming\n                 * from the current URL in the browser.\n                 */\n                _this35.rawUrlTree = t.rawUrl;\n                t.resolve(null);\n                return EMPTY;\n              }\n            }\n          }), // --- GUARDS ---\n          tap(function (t) {\n            var guardsStart = new GuardsCheckStart(t.id, _this35.serializeUrl(t.extractedUrl), _this35.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\n\n            _this35.triggerEvent(guardsStart);\n          }), map(function (t) {\n            overallTransitionState = Object.assign(Object.assign({}, t), {\n              guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, _this35.rootContexts)\n            });\n            return overallTransitionState;\n          }), checkGuards(_this35.ngModule.injector, function (evt) {\n            return _this35.triggerEvent(evt);\n          }), tap(function (t) {\n            overallTransitionState.guardsResult = t.guardsResult;\n\n            if (isUrlTree(t.guardsResult)) {\n              throw redirectingNavigationError(_this35.urlSerializer, t.guardsResult);\n            }\n\n            var guardsEnd = new GuardsCheckEnd(t.id, _this35.serializeUrl(t.extractedUrl), _this35.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\n\n            _this35.triggerEvent(guardsEnd);\n          }), filter(function (t) {\n            if (!t.guardsResult) {\n              _this35.restoreHistory(t);\n\n              _this35.cancelNavigationTransition(t, '', 3\n              /* NavigationCancellationCode.GuardRejected */\n              );\n\n              return false;\n            }\n\n            return true;\n          }), // --- RESOLVE ---\n          switchTap(function (t) {\n            if (t.guards.canActivateChecks.length) {\n              return of(t).pipe(tap(function (t) {\n                var resolveStart = new ResolveStart(t.id, _this35.serializeUrl(t.extractedUrl), _this35.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\n\n                _this35.triggerEvent(resolveStart);\n              }), switchMap(function (t) {\n                var dataResolved = false;\n                return of(t).pipe(resolveData(_this35.paramsInheritanceStrategy, _this35.ngModule.injector), tap({\n                  next: function next() {\n                    return dataResolved = true;\n                  },\n                  complete: function complete() {\n                    if (!dataResolved) {\n                      _this35.restoreHistory(t);\n\n                      _this35.cancelNavigationTransition(t, NG_DEV_MODE$2 ? \"At least one route resolver didn't emit any value.\" : '', 2\n                      /* NavigationCancellationCode.NoDataFromResolver */\n                      );\n                    }\n                  }\n                }));\n              }), tap(function (t) {\n                var resolveEnd = new ResolveEnd(t.id, _this35.serializeUrl(t.extractedUrl), _this35.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\n\n                _this35.triggerEvent(resolveEnd);\n              }));\n            }\n\n            return undefined;\n          }), // --- LOAD COMPONENTS ---\n          switchTap(function (t) {\n            var loadComponents = function loadComponents(route) {\n              var _a;\n\n              var loaders = [];\n\n              if (((_a = route.routeConfig) === null || _a === void 0 ? void 0 : _a.loadComponent) && !route.routeConfig._loadedComponent) {\n                loaders.push(_this35.configLoader.loadComponent(route.routeConfig).pipe(tap(function (loadedComponent) {\n                  route.component = loadedComponent;\n                }), map(function () {\n                  return void 0;\n                })));\n              }\n\n              var _iterator11 = _createForOfIteratorHelper(route.children),\n                  _step11;\n\n              try {\n                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                  var child = _step11.value;\n                  loaders.push.apply(loaders, _toConsumableArray(loadComponents(child)));\n                }\n              } catch (err) {\n                _iterator11.e(err);\n              } finally {\n                _iterator11.f();\n              }\n\n              return loaders;\n            };\n\n            return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(), take(1));\n          }), switchTap(function () {\n            return _this35.afterPreactivation();\n          }), map(function (t) {\n            var targetRouterState = createRouterState(_this35.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\n            overallTransitionState = Object.assign(Object.assign({}, t), {\n              targetRouterState: targetRouterState\n            });\n            return overallTransitionState;\n          }),\n          /* Once here, we are about to activate synchronously. The assumption is\n             this will succeed, and user code may read from the Router service.\n             Therefore before activation, we need to update router properties storing\n             the current URL and the RouterState, as well as updated the browser URL.\n             All this should happen *before* activating. */\n          tap(function (t) {\n            _this35.currentUrlTree = t.urlAfterRedirects;\n            _this35.rawUrlTree = _this35.urlHandlingStrategy.merge(t.urlAfterRedirects, t.rawUrl);\n            _this35.routerState = t.targetRouterState;\n\n            if (_this35.urlUpdateStrategy === 'deferred') {\n              if (!t.extras.skipLocationChange) {\n                _this35.setBrowserUrl(_this35.rawUrlTree, t);\n              }\n\n              _this35.browserUrlTree = t.urlAfterRedirects;\n            }\n          }), activateRoutes(_this35.rootContexts, _this35.routeReuseStrategy, function (evt) {\n            return _this35.triggerEvent(evt);\n          }), tap({\n            next: function next() {\n              completed = true;\n            },\n            complete: function complete() {\n              completed = true;\n            }\n          }), finalize(function () {\n            var _a;\n            /* When the navigation stream finishes either through error or success,\n             * we set the `completed` or `errored` flag. However, there are some\n             * situations where we could get here without either of those being set.\n             * For instance, a redirect during NavigationStart. Therefore, this is a\n             * catch-all to make sure the NavigationCancel event is fired when a\n             * navigation gets cancelled but not caught by other means. */\n\n\n            if (!completed && !errored) {\n              var cancelationReason = NG_DEV_MODE$2 ? \"Navigation ID \".concat(overallTransitionState.id, \" is not equal to the current navigation id \").concat(_this35.navigationId) : '';\n\n              _this35.cancelNavigationTransition(overallTransitionState, cancelationReason, 1\n              /* NavigationCancellationCode.SupersededByNewNavigation */\n              );\n            } // Only clear current navigation if it is still set to the one that\n            // finalized.\n\n\n            if (((_a = _this35.currentNavigation) === null || _a === void 0 ? void 0 : _a.id) === overallTransitionState.id) {\n              _this35.currentNavigation = null;\n            }\n          }), catchError(function (e) {\n            var _a;\n\n            errored = true;\n            /* This error type is issued during Redirect, and is handled as a\n             * cancellation rather than an error. */\n\n            if (isNavigationCancelingError$1(e)) {\n              if (!isRedirectingNavigationCancelingError$1(e)) {\n                // Set property only if we're not redirecting. If we landed on a page\n                // and redirect to `/` route, the new navigation is going to see the\n                // `/` isn't a change from the default currentUrlTree and won't\n                // navigate. This is only applicable with initial navigation, so\n                // setting `navigated` only when not redirecting resolves this\n                // scenario.\n                _this35.navigated = true;\n\n                _this35.restoreHistory(overallTransitionState, true);\n              }\n\n              var navCancel = new NavigationCancel(overallTransitionState.id, _this35.serializeUrl(overallTransitionState.extractedUrl), e.message, e.cancellationCode);\n              eventsSubject.next(navCancel); // When redirecting, we need to delay resolving the navigation\n              // promise and push it to the redirect navigation\n\n              if (!isRedirectingNavigationCancelingError$1(e)) {\n                overallTransitionState.resolve(false);\n              } else {\n                var mergedTree = _this35.urlHandlingStrategy.merge(e.url, _this35.rawUrlTree);\n\n                var extras = {\n                  skipLocationChange: overallTransitionState.extras.skipLocationChange,\n                  // The URL is already updated at this point if we have 'eager' URL\n                  // updates or if the navigation was triggered by the browser (back\n                  // button, URL bar, etc). We want to replace that item in history\n                  // if the navigation is rejected.\n                  replaceUrl: _this35.urlUpdateStrategy === 'eager' || isBrowserTriggeredNavigation(overallTransitionState.source)\n                };\n\n                _this35.scheduleNavigation(mergedTree, 'imperative', null, extras, {\n                  resolve: overallTransitionState.resolve,\n                  reject: overallTransitionState.reject,\n                  promise: overallTransitionState.promise\n                });\n              }\n              /* All other errors should reset to the router's internal URL reference\n               * to the pre-error state. */\n\n            } else {\n              _this35.restoreHistory(overallTransitionState, true);\n\n              var navError = new NavigationError(overallTransitionState.id, _this35.serializeUrl(overallTransitionState.extractedUrl), e, (_a = overallTransitionState.targetSnapshot) !== null && _a !== void 0 ? _a : undefined);\n              eventsSubject.next(navError);\n\n              try {\n                overallTransitionState.resolve(_this35.errorHandler(e));\n              } catch (ee) {\n                overallTransitionState.reject(ee);\n              }\n            }\n\n            return EMPTY;\n          })); // TODO(jasonaden): remove cast once g3 is on updated TypeScript\n        }));\n      }\n      /**\n       * @internal\n       * TODO: this should be removed once the constructor of the router made internal\n       */\n\n    }, {\n      key: \"resetRootComponentType\",\n      value: function resetRootComponentType(rootComponentType) {\n        this.rootComponentType = rootComponentType; // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n\n        this.routerState.root.component = this.rootComponentType;\n      }\n    }, {\n      key: \"setTransition\",\n      value: function setTransition(t) {\n        this.transitions.next(Object.assign(Object.assign({}, this.transitions.value), t));\n      }\n      /**\n       * Sets up the location change listener and performs the initial navigation.\n       */\n\n    }, {\n      key: \"initialNavigation\",\n      value: function initialNavigation() {\n        this.setUpLocationChangeListener();\n\n        if (this.navigationId === 0) {\n          this.navigateByUrl(this.location.path(true), {\n            replaceUrl: true\n          });\n        }\n      }\n      /**\n       * Sets up the location change listener. This listener detects navigations triggered from outside\n       * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n       * navigation so that the correct events, guards, etc. are triggered.\n       */\n\n    }, {\n      key: \"setUpLocationChangeListener\",\n      value: function setUpLocationChangeListener() {\n        var _this36 = this;\n\n        // Don't need to use Zone.wrap any more, because zone.js\n        // already patch onPopState, so location change callback will\n        // run into ngZone\n        if (!this.locationSubscription) {\n          this.locationSubscription = this.location.subscribe(function (event) {\n            var source = event['type'] === 'popstate' ? 'popstate' : 'hashchange';\n\n            if (source === 'popstate') {\n              // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n              // hybrid apps.\n              setTimeout(function () {\n                var _a;\n\n                var extras = {\n                  replaceUrl: true\n                }; // Navigations coming from Angular router have a navigationId state\n                // property. When this exists, restore the state.\n\n                var state = ((_a = event.state) === null || _a === void 0 ? void 0 : _a.navigationId) ? event.state : null;\n\n                if (state) {\n                  var stateCopy = Object.assign({}, state);\n                  delete stateCopy.navigationId;\n                  delete stateCopy.ɵrouterPageId;\n\n                  if (Object.keys(stateCopy).length !== 0) {\n                    extras.state = stateCopy;\n                  }\n                }\n\n                var urlTree = _this36.parseUrl(event['url']);\n\n                _this36.scheduleNavigation(urlTree, source, state, extras);\n              }, 0);\n            }\n          });\n        }\n      }\n      /** The current URL. */\n\n    }, {\n      key: \"url\",\n      get: function get() {\n        return this.serializeUrl(this.currentUrlTree);\n      }\n      /**\n       * Returns the current `Navigation` object when the router is navigating,\n       * and `null` when idle.\n       */\n\n    }, {\n      key: \"getCurrentNavigation\",\n      value: function getCurrentNavigation() {\n        return this.currentNavigation;\n      }\n      /** @internal */\n\n    }, {\n      key: \"triggerEvent\",\n      value: function triggerEvent(event) {\n        this.events.next(event);\n      }\n      /**\n       * Resets the route configuration used for navigation and generating links.\n       *\n       * @param config The route array for the new configuration.\n       *\n       * @usageNotes\n       *\n       * ```\n       * router.resetConfig([\n       *  { path: 'team/:id', component: TeamCmp, children: [\n       *    { path: 'simple', component: SimpleCmp },\n       *    { path: 'user/:name', component: UserCmp }\n       *  ]}\n       * ]);\n       * ```\n       */\n\n    }, {\n      key: \"resetConfig\",\n      value: function resetConfig(config) {\n        NG_DEV_MODE$2 && validateConfig(config);\n        this.config = config.map(standardizeConfig);\n        this.navigated = false;\n        this.lastSuccessfulId = -1;\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.dispose();\n      }\n      /** Disposes of the router. */\n\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this.transitions.complete();\n\n        if (this.locationSubscription) {\n          this.locationSubscription.unsubscribe();\n          this.locationSubscription = undefined;\n        }\n\n        this.disposed = true;\n      }\n      /**\n       * Appends URL segments to the current URL tree to create a new URL tree.\n       *\n       * @param commands An array of URL fragments with which to construct the new URL tree.\n       * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n       * segments, followed by the parameters for each segment.\n       * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n       * property of the options object, if supplied.\n       * @param navigationExtras Options that control the navigation strategy.\n       * @returns The new URL tree.\n       *\n       * @usageNotes\n       *\n       * ```\n       * // create /team/33/user/11\n       * router.createUrlTree(['/team', 33, 'user', 11]);\n       *\n       * // create /team/33;expand=true/user/11\n       * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n       *\n       * // you can collapse static segments like this (this works only with the first passed-in value):\n       * router.createUrlTree(['/team/33/user', userId]);\n       *\n       * // If the first segment can contain slashes, and you do not want the router to split it,\n       * // you can do the following:\n       * router.createUrlTree([{segmentPath: '/one/two'}]);\n       *\n       * // create /team/33/(user/11//right:chat)\n       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n       *\n       * // remove the right secondary node\n       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n       *\n       * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n       *\n       * // navigate to /team/33/user/11/details\n       * router.createUrlTree(['details'], {relativeTo: route});\n       *\n       * // navigate to /team/33/user/22\n       * router.createUrlTree(['../22'], {relativeTo: route});\n       *\n       * // navigate to /team/44/user/22\n       * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n       *\n       * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n       * tree should be created relative to the root.\n       * ```\n       */\n\n    }, {\n      key: \"createUrlTree\",\n      value: function createUrlTree(commands) {\n        var navigationExtras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var relativeTo = navigationExtras.relativeTo,\n            queryParams = navigationExtras.queryParams,\n            fragment = navigationExtras.fragment,\n            queryParamsHandling = navigationExtras.queryParamsHandling,\n            preserveFragment = navigationExtras.preserveFragment;\n        var a = relativeTo || this.routerState.root;\n        var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        var q = null;\n\n        switch (queryParamsHandling) {\n          case 'merge':\n            q = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), queryParams);\n            break;\n\n          case 'preserve':\n            q = this.currentUrlTree.queryParams;\n            break;\n\n          default:\n            q = queryParams || null;\n        }\n\n        if (q !== null) {\n          q = this.removeEmptyProps(q);\n        }\n\n        return _createUrlTree(a, this.currentUrlTree, commands, q, f !== null && f !== void 0 ? f : null);\n      }\n      /**\n       * Navigates to a view using an absolute route path.\n       *\n       * @param url An absolute path for a defined route. The function does not apply any delta to the\n       *     current URL.\n       * @param extras An object containing properties that modify the navigation strategy.\n       *\n       * @returns A Promise that resolves to 'true' when navigation succeeds,\n       * to 'false' when navigation fails, or is rejected on error.\n       *\n       * @usageNotes\n       *\n       * The following calls request navigation to an absolute path.\n       *\n       * ```\n       * router.navigateByUrl(\"/team/33/user/11\");\n       *\n       * // Navigate without updating the URL\n       * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n       * ```\n       *\n       * @see [Routing and Navigation guide](guide/router)\n       *\n       */\n\n    }, {\n      key: \"navigateByUrl\",\n      value: function navigateByUrl(url) {\n        var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          skipLocationChange: false\n        };\n\n        if (typeof ngDevMode === 'undefined' || ngDevMode && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {\n          this.console.warn(\"Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?\");\n        }\n\n        var urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n        var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n      }\n      /**\n       * Navigate based on the provided array of commands and a starting point.\n       * If no starting route is provided, the navigation is absolute.\n       *\n       * @param commands An array of URL fragments with which to construct the target URL.\n       * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n       * segments, followed by the parameters for each segment.\n       * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n       * of the options object, if supplied.\n       * @param extras An options object that determines how the URL should be constructed or\n       *     interpreted.\n       *\n       * @returns A Promise that resolves to `true` when navigation succeeds, to `false` when navigation\n       *     fails,\n       * or is rejected on error.\n       *\n       * @usageNotes\n       *\n       * The following calls request navigation to a dynamic route path relative to the current URL.\n       *\n       * ```\n       * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n       *\n       * // Navigate without updating the URL, overriding the default behavior\n       * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n       * ```\n       *\n       * @see [Routing and Navigation guide](guide/router)\n       *\n       */\n\n    }, {\n      key: \"navigate\",\n      value: function navigate(commands) {\n        var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          skipLocationChange: false\n        };\n        validateCommands(commands);\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n      }\n      /** Serializes a `UrlTree` into a string */\n\n    }, {\n      key: \"serializeUrl\",\n      value: function serializeUrl(url) {\n        return this.urlSerializer.serialize(url);\n      }\n      /** Parses a string into a `UrlTree` */\n\n    }, {\n      key: \"parseUrl\",\n      value: function parseUrl(url) {\n        var urlTree;\n\n        try {\n          urlTree = this.urlSerializer.parse(url);\n        } catch (e) {\n          urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);\n        }\n\n        return urlTree;\n      }\n    }, {\n      key: \"isActive\",\n      value: function isActive(url, matchOptions) {\n        var options;\n\n        if (matchOptions === true) {\n          options = Object.assign({}, exactMatchOptions);\n        } else if (matchOptions === false) {\n          options = Object.assign({}, subsetMatchOptions);\n        } else {\n          options = matchOptions;\n        }\n\n        if (isUrlTree(url)) {\n          return containsTree(this.currentUrlTree, url, options);\n        }\n\n        var urlTree = this.parseUrl(url);\n        return containsTree(this.currentUrlTree, urlTree, options);\n      }\n    }, {\n      key: \"removeEmptyProps\",\n      value: function removeEmptyProps(params) {\n        return Object.keys(params).reduce(function (result, key) {\n          var value = params[key];\n\n          if (value !== null && value !== undefined) {\n            result[key] = value;\n          }\n\n          return result;\n        }, {});\n      }\n    }, {\n      key: \"processNavigations\",\n      value: function processNavigations() {\n        var _this37 = this;\n\n        this.navigations.subscribe(function (t) {\n          var _a;\n\n          _this37.navigated = true;\n          _this37.lastSuccessfulId = t.id;\n          _this37.currentPageId = t.targetPageId;\n\n          _this37.events.next(new NavigationEnd(t.id, _this37.serializeUrl(t.extractedUrl), _this37.serializeUrl(_this37.currentUrlTree)));\n\n          _this37.lastSuccessfulNavigation = _this37.currentNavigation;\n          (_a = _this37.titleStrategy) === null || _a === void 0 ? void 0 : _a.updateTitle(_this37.routerState.snapshot);\n          t.resolve(true);\n        }, function (e) {\n          _this37.console.warn(\"Unhandled Navigation Error: \".concat(e));\n        });\n      }\n    }, {\n      key: \"scheduleNavigation\",\n      value: function scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\n        var _a, _b;\n\n        if (this.disposed) {\n          return Promise.resolve(false);\n        }\n\n        var resolve;\n        var reject;\n        var promise;\n\n        if (priorPromise) {\n          resolve = priorPromise.resolve;\n          reject = priorPromise.reject;\n          promise = priorPromise.promise;\n        } else {\n          promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n          });\n        }\n\n        var id = ++this.navigationId;\n        var targetPageId;\n\n        if (this.canceledNavigationResolution === 'computed') {\n          var isInitialPage = this.currentPageId === 0;\n\n          if (isInitialPage) {\n            restoredState = this.location.getState();\n          } // If the `ɵrouterPageId` exist in the state then `targetpageId` should have the value of\n          // `ɵrouterPageId`. This is the case for something like a page refresh where we assign the\n          // target id to the previously set value for that page.\n\n\n          if (restoredState && restoredState.ɵrouterPageId) {\n            targetPageId = restoredState.ɵrouterPageId;\n          } else {\n            // If we're replacing the URL or doing a silent navigation, we do not want to increment the\n            // page id because we aren't pushing a new entry to history.\n            if (extras.replaceUrl || extras.skipLocationChange) {\n              targetPageId = (_a = this.browserPageId) !== null && _a !== void 0 ? _a : 0;\n            } else {\n              targetPageId = ((_b = this.browserPageId) !== null && _b !== void 0 ? _b : 0) + 1;\n            }\n          }\n        } else {\n          // This is unused when `canceledNavigationResolution` is not computed.\n          targetPageId = 0;\n        }\n\n        this.setTransition({\n          id: id,\n          targetPageId: targetPageId,\n          source: source,\n          restoredState: restoredState,\n          currentUrlTree: this.currentUrlTree,\n          currentRawUrl: this.rawUrlTree,\n          rawUrl: rawUrl,\n          extras: extras,\n          resolve: resolve,\n          reject: reject,\n          promise: promise,\n          currentSnapshot: this.routerState.snapshot,\n          currentRouterState: this.routerState\n        }); // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n\n        return promise.catch(function (e) {\n          return Promise.reject(e);\n        });\n      }\n    }, {\n      key: \"setBrowserUrl\",\n      value: function setBrowserUrl(url, t) {\n        var path = this.urlSerializer.serialize(url);\n        var state = Object.assign(Object.assign({}, t.extras.state), this.generateNgRouterState(t.id, t.targetPageId));\n\n        if (this.location.isCurrentPathEqualTo(path) || !!t.extras.replaceUrl) {\n          this.location.replaceState(path, '', state);\n        } else {\n          this.location.go(path, '', state);\n        }\n      }\n      /**\n       * Performs the necessary rollback action to restore the browser URL to the\n       * state before the transition.\n       */\n\n    }, {\n      key: \"restoreHistory\",\n      value: function restoreHistory(t) {\n        var restoringFromCaughtError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var _a, _b;\n\n        if (this.canceledNavigationResolution === 'computed') {\n          var targetPagePosition = this.currentPageId - t.targetPageId; // The navigator change the location before triggered the browser event,\n          // so we need to go back to the current url if the navigation is canceled.\n          // Also, when navigation gets cancelled while using url update strategy eager, then we need to\n          // go back. Because, when `urlUpdateStrategy` is `eager`; `setBrowserUrl` method is called\n          // before any verification.\n\n          var browserUrlUpdateOccurred = t.source === 'popstate' || this.urlUpdateStrategy === 'eager' || this.currentUrlTree === ((_a = this.currentNavigation) === null || _a === void 0 ? void 0 : _a.finalUrl);\n\n          if (browserUrlUpdateOccurred && targetPagePosition !== 0) {\n            this.location.historyGo(targetPagePosition);\n          } else if (this.currentUrlTree === ((_b = this.currentNavigation) === null || _b === void 0 ? void 0 : _b.finalUrl) && targetPagePosition === 0) {\n            // We got to the activation stage (where currentUrlTree is set to the navigation's\n            // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n            // We still need to reset the router state back to what it was when the navigation started.\n            this.resetState(t); // TODO(atscott): resetting the `browserUrlTree` should really be done in `resetState`.\n            // Investigate if this can be done by running TGP.\n\n            this.browserUrlTree = t.currentUrlTree;\n            this.resetUrlToCurrentUrlTree();\n          } else {// The browser URL and router state was not updated before the navigation cancelled so\n            // there's no restoration needed.\n          }\n        } else if (this.canceledNavigationResolution === 'replace') {\n          // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n          // for `deferred` navigations that haven't change the internal state yet because guards\n          // reject. For 'eager' navigations, it seems like we also really should reset the state\n          // because the navigation was cancelled. Investigate if this can be done by running TGP.\n          if (restoringFromCaughtError) {\n            this.resetState(t);\n          }\n\n          this.resetUrlToCurrentUrlTree();\n        }\n      }\n    }, {\n      key: \"resetState\",\n      value: function resetState(t) {\n        this.routerState = t.currentRouterState;\n        this.currentUrlTree = t.currentUrlTree; // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n        // configured to handle only part of the navigation URL. This means we would only want to reset\n        // the part of the navigation handled by the Angular router rather than the whole URL. In\n        // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n        // when merging, such as the query params so they are not lost on a refresh.\n\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);\n      }\n    }, {\n      key: \"resetUrlToCurrentUrlTree\",\n      value: function resetUrlToCurrentUrlTree() {\n        this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n      }\n    }, {\n      key: \"cancelNavigationTransition\",\n      value: function cancelNavigationTransition(t, reason, code) {\n        var navCancel = new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), reason, code);\n        this.triggerEvent(navCancel);\n        t.resolve(false);\n      }\n    }, {\n      key: \"generateNgRouterState\",\n      value: function generateNgRouterState(navigationId, routerPageId) {\n        if (this.canceledNavigationResolution === 'computed') {\n          return {\n            navigationId: navigationId,\n            ɵrouterPageId: routerPageId\n          };\n        }\n\n        return {\n          navigationId: navigationId\n        };\n      }\n    }]);\n\n    return Router;\n  }();\n\n  Router.ɵfac = function Router_Factory(t) {\n    i0.ɵɵinvalidFactory();\n  };\n\n  Router.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Router,\n    factory: function factory() {\n      return setupRouter();\n    },\n    providedIn: 'root'\n  });\n  return Router;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction validateCommands(commands) {\n  for (var i = 0; i < commands.length; i++) {\n    var cmd = commands[i];\n\n    if (cmd == null) {\n      throw new ɵRuntimeError(4008\n      /* RuntimeErrorCode.NULLISH_COMMAND */\n      , NG_DEV_MODE$2 && \"The requested path contains \".concat(cmd, \" segment at index \").concat(i));\n    }\n  }\n}\n\nfunction isBrowserTriggeredNavigation(source) {\n  return source !== 'imperative';\n}\n/**\n * @description\n *\n * When applied to an element in a template, makes that element a link\n * that initiates navigation to a route. Navigation opens one or more routed components\n * in one or more `<router-outlet>` locations on the page.\n *\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\n * the following creates a static link to the route:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * You can use dynamic values to generate the link.\n * For a dynamic link, pass an array of path segments,\n * followed by the params for each segment.\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\n * generates a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one term and combined with dynamic segments.\n * For example, `['/team/11/user', userName, {details: true}]`\n *\n * The input that you provide to the link is treated as a delta to the current URL.\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\n * `/user/(jim//aux:team)`.\n * See {@link Router#createUrlTree createUrlTree} for more information.\n *\n * @usageNotes\n *\n * You can use absolute or relative paths in a link, set query parameters,\n * control how parameters are handled, and keep a history of navigation states.\n *\n * ### Relative link paths\n *\n * The first segment name can be prepended with `/`, `./`, or `../`.\n * * If the first segment begins with `/`, the router looks up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\n *   looks in the children of the current activated route.\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\n *\n * ### Setting and handling query params and fragments\n *\n * The following link adds a query parameter and a fragment to the generated URL:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * By default, the directive constructs the new URL using the given query parameters.\n * The example generates the link: `/user/bob?debug=true#education`.\n *\n * You can instruct the directive to handle query parameters differently\n * by specifying the `queryParamsHandling` option in the link.\n * Allowed values are:\n *\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\n *  - `'preserve'`: Preserve the current query params.\n *\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * See {@link UrlCreationOptions.queryParamsHandling UrlCreationOptions#queryParamsHandling}.\n *\n * ### Preserving navigation history\n *\n * You can provide a `state` value to be persisted to the browser's\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * Use {@link Router.getCurrentNavigation() Router#getCurrentNavigation} to retrieve a saved\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\n * event:\n *\n * ```\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n\n\nvar RouterLink = /*#__PURE__*/(function () {\n  var RouterLink = /*#__PURE__*/function () {\n    function RouterLink(router, route, tabIndexAttribute, renderer, el) {\n      _classCallCheck(this, RouterLink);\n\n      this.router = router;\n      this.route = route;\n      this.tabIndexAttribute = tabIndexAttribute;\n      this.renderer = renderer;\n      this.el = el;\n      this._preserveFragment = false;\n      this._skipLocationChange = false;\n      this._replaceUrl = false;\n      this.commands = null;\n      /** @internal */\n\n      this.onChanges = new Subject();\n      this.setTabIndexIfNotOnNativeEl('0');\n    }\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#preserveFragment UrlCreationOptions#preserveFragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n\n\n    _createClass(RouterLink, [{\n      key: \"preserveFragment\",\n      get: function get() {\n        return this._preserveFragment;\n      }\n      /**\n       * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n       * `NavigationBehaviorOptions`.\n       * @see {@link NavigationBehaviorOptions#skipLocationChange NavigationBehaviorOptions#skipLocationChange}\n       * @see {@link Router#navigateByUrl Router#navigateByUrl}\n       */\n      ,\n      set: function set(preserveFragment) {\n        this._preserveFragment = ɵcoerceToBoolean(preserveFragment);\n      }\n    }, {\n      key: \"skipLocationChange\",\n      get: function get() {\n        return this._skipLocationChange;\n      }\n      /**\n       * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n       * `NavigationBehaviorOptions`.\n       * @see {@link NavigationBehaviorOptions#replaceUrl NavigationBehaviorOptions#replaceUrl}\n       * @see {@link Router#navigateByUrl Router#navigateByUrl}\n       */\n      ,\n      set: function set(skipLocationChange) {\n        this._skipLocationChange = ɵcoerceToBoolean(skipLocationChange);\n      }\n    }, {\n      key: \"replaceUrl\",\n      get: function get() {\n        return this._replaceUrl;\n      }\n      /**\n       * Modifies the tab index if there was not a tabindex attribute on the element during\n       * instantiation.\n       */\n      ,\n      set: function set(replaceUrl) {\n        this._replaceUrl = ɵcoerceToBoolean(replaceUrl);\n      }\n    }, {\n      key: \"setTabIndexIfNotOnNativeEl\",\n      value: function setTabIndexIfNotOnNativeEl(newTabIndex) {\n        if (this.tabIndexAttribute != null\n        /* both `null` and `undefined` */\n        ) {\n          return;\n        }\n\n        var renderer = this.renderer;\n        var nativeElement = this.el.nativeElement;\n\n        if (newTabIndex !== null) {\n          renderer.setAttribute(nativeElement, 'tabindex', newTabIndex);\n        } else {\n          renderer.removeAttribute(nativeElement, 'tabindex');\n        }\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        // This is subscribed to by `RouterLinkActive` so that it knows to update when there are changes\n        // to the RouterLinks it's tracking.\n        this.onChanges.next(this);\n      }\n      /**\n       * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n       *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n       *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n       *   - **null|undefined**: effectively disables the `routerLink`\n       * @see {@link Router#createUrlTree Router#createUrlTree}\n       */\n\n    }, {\n      key: \"routerLink\",\n      set: function set(commands) {\n        if (commands != null) {\n          this.commands = Array.isArray(commands) ? commands : [commands];\n          this.setTabIndexIfNotOnNativeEl('0');\n        } else {\n          this.commands = null;\n          this.setTabIndexIfNotOnNativeEl(null);\n        }\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick() {\n        if (this.urlTree === null) {\n          return true;\n        }\n\n        var extras = {\n          skipLocationChange: this.skipLocationChange,\n          replaceUrl: this.replaceUrl,\n          state: this.state\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return true;\n      }\n    }, {\n      key: \"urlTree\",\n      get: function get() {\n        if (this.commands === null) {\n          return null;\n        }\n\n        return this.router.createUrlTree(this.commands, {\n          // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n          // Otherwise, we should use the value provided by the user in the input.\n          relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n          queryParams: this.queryParams,\n          fragment: this.fragment,\n          queryParamsHandling: this.queryParamsHandling,\n          preserveFragment: this.preserveFragment\n        });\n      }\n    }]);\n\n    return RouterLink;\n  }();\n\n  RouterLink.ɵfac = function RouterLink_Factory(t) {\n    return new (t || RouterLink)(i0.ɵɵdirectiveInject(Router), i0.ɵɵdirectiveInject(ActivatedRoute), i0.ɵɵinjectAttribute('tabindex'), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  RouterLink.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterLink,\n    selectors: [[\"\", \"routerLink\", \"\", 5, \"a\", 5, \"area\"]],\n    hostBindings: function RouterLink_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function RouterLink_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      queryParams: \"queryParams\",\n      fragment: \"fragment\",\n      queryParamsHandling: \"queryParamsHandling\",\n      state: \"state\",\n      relativeTo: \"relativeTo\",\n      preserveFragment: \"preserveFragment\",\n      skipLocationChange: \"skipLocationChange\",\n      replaceUrl: \"replaceUrl\",\n      routerLink: \"routerLink\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return RouterLink;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n\n\nvar RouterLinkWithHref = /*#__PURE__*/(function () {\n  var RouterLinkWithHref = /*#__PURE__*/function () {\n    function RouterLinkWithHref(router, route, locationStrategy) {\n      var _this38 = this;\n\n      _classCallCheck(this, RouterLinkWithHref);\n\n      this.router = router;\n      this.route = route;\n      this.locationStrategy = locationStrategy;\n      this._preserveFragment = false;\n      this._skipLocationChange = false;\n      this._replaceUrl = false;\n      this.commands = null; // the url displayed on the anchor element.\n      // @HostBinding('attr.href') is used rather than @HostBinding() because it removes the\n      // href attribute when it becomes `null`.\n\n      this.href = null;\n      /** @internal */\n\n      this.onChanges = new Subject();\n      this.subscription = router.events.subscribe(function (s) {\n        if (s instanceof NavigationEnd) {\n          _this38.updateTargetUrlAndHref();\n        }\n      });\n    }\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#preserveFragment UrlCreationOptions#preserveFragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n\n\n    _createClass(RouterLinkWithHref, [{\n      key: \"preserveFragment\",\n      get: function get() {\n        return this._preserveFragment;\n      }\n      /**\n       * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n       * `NavigationBehaviorOptions`.\n       * @see {@link NavigationBehaviorOptions#skipLocationChange NavigationBehaviorOptions#skipLocationChange}\n       * @see {@link Router#navigateByUrl Router#navigateByUrl}\n       */\n      ,\n      set: function set(preserveFragment) {\n        this._preserveFragment = ɵcoerceToBoolean(preserveFragment);\n      }\n    }, {\n      key: \"skipLocationChange\",\n      get: function get() {\n        return this._skipLocationChange;\n      }\n      /**\n       * Passed to {@link Router#navigateByUrl Router#navigateByUrl} as part of the\n       * `NavigationBehaviorOptions`.\n       * @see {@link NavigationBehaviorOptions#replaceUrl NavigationBehaviorOptions#replaceUrl}\n       * @see {@link Router#navigateByUrl Router#navigateByUrl}\n       */\n      ,\n      set: function set(skipLocationChange) {\n        this._skipLocationChange = ɵcoerceToBoolean(skipLocationChange);\n      }\n    }, {\n      key: \"replaceUrl\",\n      get: function get() {\n        return this._replaceUrl;\n      }\n      /**\n       * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n       *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n       *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n       *   - **null|undefined**: Disables the link by removing the `href`\n       * @see {@link Router#createUrlTree Router#createUrlTree}\n       */\n      ,\n      set: function set(replaceUrl) {\n        this._replaceUrl = ɵcoerceToBoolean(replaceUrl);\n      }\n    }, {\n      key: \"routerLink\",\n      set: function set(commands) {\n        if (commands != null) {\n          this.commands = Array.isArray(commands) ? commands : [commands];\n        } else {\n          this.commands = null;\n        }\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.updateTargetUrlAndHref();\n        this.onChanges.next(this);\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(button, ctrlKey, shiftKey, altKey, metaKey) {\n        if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n          return true;\n        }\n\n        if (typeof this.target === 'string' && this.target != '_self' || this.urlTree === null) {\n          return true;\n        }\n\n        var extras = {\n          skipLocationChange: this.skipLocationChange,\n          replaceUrl: this.replaceUrl,\n          state: this.state\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return false;\n      }\n    }, {\n      key: \"updateTargetUrlAndHref\",\n      value: function updateTargetUrlAndHref() {\n        this.href = this.urlTree !== null ? this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null;\n      }\n    }, {\n      key: \"urlTree\",\n      get: function get() {\n        if (this.commands === null) {\n          return null;\n        }\n\n        return this.router.createUrlTree(this.commands, {\n          // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n          // Otherwise, we should use the value provided by the user in the input.\n          relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n          queryParams: this.queryParams,\n          fragment: this.fragment,\n          queryParamsHandling: this.queryParamsHandling,\n          preserveFragment: this.preserveFragment\n        });\n      }\n    }]);\n\n    return RouterLinkWithHref;\n  }();\n\n  RouterLinkWithHref.ɵfac = function RouterLinkWithHref_Factory(t) {\n    return new (t || RouterLinkWithHref)(i0.ɵɵdirectiveInject(Router), i0.ɵɵdirectiveInject(ActivatedRoute), i0.ɵɵdirectiveInject(i3.LocationStrategy));\n  };\n\n  RouterLinkWithHref.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterLinkWithHref,\n    selectors: [[\"a\", \"routerLink\", \"\"], [\"area\", \"routerLink\", \"\"]],\n    hostVars: 2,\n    hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function RouterLinkWithHref_click_HostBindingHandler($event) {\n          return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"target\", ctx.target)(\"href\", ctx.href, i0.ɵɵsanitizeUrl);\n      }\n    },\n    inputs: {\n      target: \"target\",\n      queryParams: \"queryParams\",\n      fragment: \"fragment\",\n      queryParamsHandling: \"queryParamsHandling\",\n      state: \"state\",\n      relativeTo: \"relativeTo\",\n      preserveFragment: \"preserveFragment\",\n      skipLocationChange: \"skipLocationChange\",\n      replaceUrl: \"replaceUrl\",\n      routerLink: \"routerLink\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return RouterLinkWithHref;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n *\n * @description\n *\n * Tracks whether the linked route of an element is currently active, and allows you\n * to specify one or more CSS classes to add to the element when the linked route\n * is active.\n *\n * Use this directive to create a visual distinction for elements associated with an active route.\n * For example, the following code highlights the word \"Bob\" when the router\n * activates the associated route:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\n * added to the anchor tag. If the URL changes, the class is removed.\n *\n * You can set more than one class using a space-separated string or an array.\n * For example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\n * instance to a template variable.\n * For example, the following checks the status without assigning any CSS classes:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\n * For example, the following sets the active-link class on the `<div>`  parent tag\n * when the URL is either '/user/jim' or '/user/bob'.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * The `RouterLinkActive` directive can also be used to set the aria-current attribute\n * to provide an alternative distinction for active elements to visually impaired users.\n *\n * For example, the following code adds the 'active' class to the Home Page link when it is\n * indeed active and in such case also sets its aria-current attribute to 'page':\n *\n * ```\n * <a routerLink=\"/\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Home Page</a>\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n\n\nvar RouterLinkActive = /*#__PURE__*/(function () {\n  var RouterLinkActive = /*#__PURE__*/function () {\n    function RouterLinkActive(router, element, renderer, cdr, link, linkWithHref) {\n      var _this39 = this;\n\n      _classCallCheck(this, RouterLinkActive);\n\n      this.router = router;\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.link = link;\n      this.linkWithHref = linkWithHref;\n      this.classes = [];\n      this.isActive = false;\n      /**\n       * Options to configure how to determine if the router link is active.\n       *\n       * These options are passed to the `Router.isActive()` function.\n       *\n       * @see Router.isActive\n       */\n\n      this.routerLinkActiveOptions = {\n        exact: false\n      };\n      /**\n       *\n       * You can use the output `isActiveChange` to get notified each time the link becomes\n       * active or inactive.\n       *\n       * Emits:\n       * true  -> Route is active\n       * false -> Route is inactive\n       *\n       * ```\n       * <a\n       *  routerLink=\"/user/bob\"\n       *  routerLinkActive=\"active-link\"\n       *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\n       * ```\n       */\n\n      this.isActiveChange = new EventEmitter();\n      this.routerEventsSubscription = router.events.subscribe(function (s) {\n        if (s instanceof NavigationEnd) {\n          _this39.update();\n        }\n      });\n    }\n    /** @nodoc */\n\n\n    _createClass(RouterLinkActive, [{\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        var _this40 = this;\n\n        // `of(null)` is used to force subscribe body to execute once immediately (like `startWith`).\n        of(this.links.changes, this.linksWithHrefs.changes, of(null)).pipe(mergeAll()).subscribe(function (_) {\n          _this40.update();\n\n          _this40.subscribeToEachLinkOnChanges();\n        });\n      }\n    }, {\n      key: \"subscribeToEachLinkOnChanges\",\n      value: function subscribeToEachLinkOnChanges() {\n        var _this41 = this;\n\n        var _a;\n\n        (_a = this.linkInputChangesSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        var allLinkChanges = [].concat(_toConsumableArray(this.links.toArray()), _toConsumableArray(this.linksWithHrefs.toArray()), [this.link, this.linkWithHref]).filter(function (link) {\n          return !!link;\n        }).map(function (link) {\n          return link.onChanges;\n        });\n        this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe(function (link) {\n          if (_this41.isActive !== _this41.isLinkActive(_this41.router)(link)) {\n            _this41.update();\n          }\n        });\n      }\n    }, {\n      key: \"routerLinkActive\",\n      set: function set(data) {\n        var classes = Array.isArray(data) ? data : data.split(' ');\n        this.classes = classes.filter(function (c) {\n          return !!c;\n        });\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.update();\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var _a;\n\n        this.routerEventsSubscription.unsubscribe();\n        (_a = this.linkInputChangesSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        var _this42 = this;\n\n        if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;\n        Promise.resolve().then(function () {\n          var hasActiveLinks = _this42.hasActiveLinks();\n\n          if (_this42.isActive !== hasActiveLinks) {\n            _this42.isActive = hasActiveLinks;\n\n            _this42.cdr.markForCheck();\n\n            _this42.classes.forEach(function (c) {\n              if (hasActiveLinks) {\n                _this42.renderer.addClass(_this42.element.nativeElement, c);\n              } else {\n                _this42.renderer.removeClass(_this42.element.nativeElement, c);\n              }\n            });\n\n            if (hasActiveLinks && _this42.ariaCurrentWhenActive !== undefined) {\n              _this42.renderer.setAttribute(_this42.element.nativeElement, 'aria-current', _this42.ariaCurrentWhenActive.toString());\n            } else {\n              _this42.renderer.removeAttribute(_this42.element.nativeElement, 'aria-current');\n            } // Emit on isActiveChange after classes are updated\n\n\n            _this42.isActiveChange.emit(hasActiveLinks);\n          }\n        });\n      }\n    }, {\n      key: \"isLinkActive\",\n      value: function isLinkActive(router) {\n        var options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : // While the types should disallow `undefined` here, it's possible without strict inputs\n        this.routerLinkActiveOptions.exact || false;\n        return function (link) {\n          return link.urlTree ? router.isActive(link.urlTree, options) : false;\n        };\n      }\n    }, {\n      key: \"hasActiveLinks\",\n      value: function hasActiveLinks() {\n        var isActiveCheckFn = this.isLinkActive(this.router);\n        return this.link && isActiveCheckFn(this.link) || this.linkWithHref && isActiveCheckFn(this.linkWithHref) || this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);\n      }\n    }]);\n\n    return RouterLinkActive;\n  }();\n\n  RouterLinkActive.ɵfac = function RouterLinkActive_Factory(t) {\n    return new (t || RouterLinkActive)(i0.ɵɵdirectiveInject(Router), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(RouterLink, 8), i0.ɵɵdirectiveInject(RouterLinkWithHref, 8));\n  };\n\n  RouterLinkActive.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterLinkActive,\n    selectors: [[\"\", \"routerLinkActive\", \"\"]],\n    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, RouterLink, 5);\n        i0.ɵɵcontentQuery(dirIndex, RouterLinkWithHref, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.links = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linksWithHrefs = _t);\n      }\n    },\n    inputs: {\n      routerLinkActiveOptions: \"routerLinkActiveOptions\",\n      ariaCurrentWhenActive: \"ariaCurrentWhenActive\",\n      routerLinkActive: \"routerLinkActive\"\n    },\n    outputs: {\n      isActiveChange: \"isActiveChange\"\n    },\n    exportAs: [\"routerLinkActive\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return RouterLinkActive;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use instead of `'paths' in options` to be compatible with property renaming\n */\n\n\nfunction isActiveMatchOptions(options) {\n  return !!options.paths;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\n\n\nvar PreloadingStrategy = /*#__PURE__*/_createClass(function PreloadingStrategy() {\n  _classCallCheck(this, PreloadingStrategy);\n});\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\n\n\nvar PreloadAllModules = /*#__PURE__*/(function () {\n  var PreloadAllModules = /*#__PURE__*/function () {\n    function PreloadAllModules() {\n      _classCallCheck(this, PreloadAllModules);\n    }\n\n    _createClass(PreloadAllModules, [{\n      key: \"preload\",\n      value: function preload(route, fn) {\n        return fn().pipe(catchError(function () {\n          return of(null);\n        }));\n      }\n    }]);\n\n    return PreloadAllModules;\n  }();\n\n  PreloadAllModules.ɵfac = function PreloadAllModules_Factory(t) {\n    return new (t || PreloadAllModules)();\n  };\n\n  PreloadAllModules.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PreloadAllModules,\n    factory: PreloadAllModules.ɵfac,\n    providedIn: 'root'\n  });\n  return PreloadAllModules;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\n\n\nvar NoPreloading = /*#__PURE__*/(function () {\n  var NoPreloading = /*#__PURE__*/function () {\n    function NoPreloading() {\n      _classCallCheck(this, NoPreloading);\n    }\n\n    _createClass(NoPreloading, [{\n      key: \"preload\",\n      value: function preload(route, fn) {\n        return of(null);\n      }\n    }]);\n\n    return NoPreloading;\n  }();\n\n  NoPreloading.ɵfac = function NoPreloading_Factory(t) {\n    return new (t || NoPreloading)();\n  };\n\n  NoPreloading.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NoPreloading,\n    factory: NoPreloading.ɵfac,\n    providedIn: 'root'\n  });\n  return NoPreloading;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\n\n\nvar RouterPreloader = /*#__PURE__*/(function () {\n  var RouterPreloader = /*#__PURE__*/function () {\n    function RouterPreloader(router, compiler, injector, preloadingStrategy, loader) {\n      _classCallCheck(this, RouterPreloader);\n\n      this.router = router;\n      this.injector = injector;\n      this.preloadingStrategy = preloadingStrategy;\n      this.loader = loader;\n    }\n\n    _createClass(RouterPreloader, [{\n      key: \"setUpPreloading\",\n      value: function setUpPreloading() {\n        var _this43 = this;\n\n        this.subscription = this.router.events.pipe(filter(function (e) {\n          return e instanceof NavigationEnd;\n        }), concatMap(function () {\n          return _this43.preload();\n        })).subscribe(function () {});\n      }\n    }, {\n      key: \"preload\",\n      value: function preload() {\n        return this.processRoutes(this.injector, this.router.config);\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.subscription) {\n          this.subscription.unsubscribe();\n        }\n      }\n    }, {\n      key: \"processRoutes\",\n      value: function processRoutes(injector, routes) {\n        var _a, _b, _c;\n\n        var res = [];\n\n        var _iterator12 = _createForOfIteratorHelper(routes),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var route = _step12.value;\n\n            if (route.providers && !route._injector) {\n              route._injector = createEnvironmentInjector(route.providers, injector, \"Route: \".concat(route.path));\n            }\n\n            var injectorForCurrentRoute = (_a = route._injector) !== null && _a !== void 0 ? _a : injector;\n            var injectorForChildren = (_b = route._loadedInjector) !== null && _b !== void 0 ? _b : injectorForCurrentRoute; // Note that `canLoad` is only checked as a condition that prevents `loadChildren` and not\n            // `loadComponent`. `canLoad` guards only block loading of child routes by design. This\n            // happens as a consequence of needing to descend into children for route matching immediately\n            // while component loading is deferred until route activation. Because `canLoad` guards can\n            // have side effects, we cannot execute them here so we instead skip preloading altogether\n            // when present. Lastly, it remains to be decided whether `canLoad` should behave this way\n            // at all. Code splitting and lazy loading is separate from client-side authorization checks\n            // and should not be used as a security measure to prevent loading of code.\n\n            if (route.loadChildren && !route._loadedRoutes && route.canLoad === undefined || route.loadComponent && !route._loadedComponent) {\n              res.push(this.preloadConfig(injectorForCurrentRoute, route));\n            } else if (route.children || route._loadedRoutes) {\n              res.push(this.processRoutes(injectorForChildren, (_c = route.children) !== null && _c !== void 0 ? _c : route._loadedRoutes));\n            }\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n\n        return from(res).pipe(mergeAll());\n      }\n    }, {\n      key: \"preloadConfig\",\n      value: function preloadConfig(injector, route) {\n        var _this44 = this;\n\n        return this.preloadingStrategy.preload(route, function () {\n          var loadedChildren$;\n\n          if (route.loadChildren && route.canLoad === undefined) {\n            loadedChildren$ = _this44.loader.loadChildren(injector, route);\n          } else {\n            loadedChildren$ = of(null);\n          }\n\n          var recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap(function (config) {\n            var _a;\n\n            if (config === null) {\n              return of(void 0);\n            }\n\n            route._loadedRoutes = config.routes;\n            route._loadedInjector = config.injector; // If the loaded config was a module, use that as the module/module injector going\n            // forward. Otherwise, continue using the current module/module injector.\n\n            return _this44.processRoutes((_a = config.injector) !== null && _a !== void 0 ? _a : injector, config.routes);\n          }));\n\n          if (route.loadComponent && !route._loadedComponent) {\n            var loadComponent$ = _this44.loader.loadComponent(route);\n\n            return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n          } else {\n            return recursiveLoadChildren$;\n          }\n        });\n      }\n    }]);\n\n    return RouterPreloader;\n  }();\n\n  RouterPreloader.ɵfac = function RouterPreloader_Factory(t) {\n    return new (t || RouterPreloader)(i0.ɵɵinject(Router), i0.ɵɵinject(i0.Compiler), i0.ɵɵinject(i0.EnvironmentInjector), i0.ɵɵinject(PreloadingStrategy), i0.ɵɵinject(RouterConfigLoader));\n  };\n\n  RouterPreloader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouterPreloader,\n    factory: RouterPreloader.ɵfac,\n    providedIn: 'root'\n  });\n  return RouterPreloader;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ROUTER_SCROLLER = /*#__PURE__*/new InjectionToken('');\nvar RouterScroller = /*#__PURE__*/(function () {\n  var RouterScroller = /*#__PURE__*/function () {\n    function RouterScroller(router,\n    /** @docsNotRequired */\n    viewportScroller) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      _classCallCheck(this, RouterScroller);\n\n      this.router = router;\n      this.viewportScroller = viewportScroller;\n      this.options = options;\n      this.lastId = 0;\n      this.lastSource = 'imperative';\n      this.restoredId = 0;\n      this.store = {}; // Default both options to 'disabled'\n\n      options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';\n      options.anchorScrolling = options.anchorScrolling || 'disabled';\n    }\n\n    _createClass(RouterScroller, [{\n      key: \"init\",\n      value: function init() {\n        // we want to disable the automatic scrolling because having two places\n        // responsible for scrolling results race conditions, especially given\n        // that browser don't implement this behavior consistently\n        if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.setHistoryScrollRestoration('manual');\n        }\n\n        this.routerEventsSubscription = this.createScrollEvents();\n        this.scrollEventsSubscription = this.consumeScrollEvents();\n      }\n    }, {\n      key: \"createScrollEvents\",\n      value: function createScrollEvents() {\n        var _this45 = this;\n\n        return this.router.events.subscribe(function (e) {\n          if (e instanceof NavigationStart) {\n            // store the scroll position of the current stable navigations.\n            _this45.store[_this45.lastId] = _this45.viewportScroller.getScrollPosition();\n            _this45.lastSource = e.navigationTrigger;\n            _this45.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n          } else if (e instanceof NavigationEnd) {\n            _this45.lastId = e.id;\n\n            _this45.scheduleScrollEvent(e, _this45.router.parseUrl(e.urlAfterRedirects).fragment);\n          }\n        });\n      }\n    }, {\n      key: \"consumeScrollEvents\",\n      value: function consumeScrollEvents() {\n        var _this46 = this;\n\n        return this.router.events.subscribe(function (e) {\n          if (!(e instanceof Scroll)) return; // a popstate event. The pop state event will always ignore anchor scrolling.\n\n          if (e.position) {\n            if (_this46.options.scrollPositionRestoration === 'top') {\n              _this46.viewportScroller.scrollToPosition([0, 0]);\n            } else if (_this46.options.scrollPositionRestoration === 'enabled') {\n              _this46.viewportScroller.scrollToPosition(e.position);\n            } // imperative navigation \"forward\"\n\n          } else {\n            if (e.anchor && _this46.options.anchorScrolling === 'enabled') {\n              _this46.viewportScroller.scrollToAnchor(e.anchor);\n            } else if (_this46.options.scrollPositionRestoration !== 'disabled') {\n              _this46.viewportScroller.scrollToPosition([0, 0]);\n            }\n          }\n        });\n      }\n    }, {\n      key: \"scheduleScrollEvent\",\n      value: function scheduleScrollEvent(routerEvent, anchor) {\n        this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));\n      }\n      /** @nodoc */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.routerEventsSubscription) {\n          this.routerEventsSubscription.unsubscribe();\n        }\n\n        if (this.scrollEventsSubscription) {\n          this.scrollEventsSubscription.unsubscribe();\n        }\n      }\n    }]);\n\n    return RouterScroller;\n  }();\n\n  RouterScroller.ɵfac = function RouterScroller_Factory(t) {\n    i0.ɵɵinvalidFactory();\n  };\n\n  RouterScroller.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouterScroller,\n    factory: RouterScroller.ɵfac\n  });\n  return RouterScroller;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE$1 = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * Sets up providers necessary to enable `Router` functionality for the application.\n * Allows to configure a set of routes as well as extra features that should be enabled.\n *\n * @usageNotes\n *\n * Basic example of how you can add a Router to your application:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent, {\n *   providers: [provideRouter(appRoutes)]\n * });\n * ```\n *\n * You can also enable optional features in the Router by adding functions from the `RouterFeatures`\n * type:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes,\n *         withDebugTracing(),\n *         withRouterConfig({paramsInheritanceStrategy: 'always'}))\n *     ]\n *   }\n * );\n * ```\n *\n * @see `RouterFeatures`\n *\n * @publicApi\n * @developerPreview\n * @param routes A set of `Route`s to use for the application routing table.\n * @param features Optional features to configure additional router behaviors.\n * @returns A set of providers to setup a Router.\n */\n\nfunction provideRouter(routes) {\n  for (var _len = arguments.length, features = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    features[_key - 1] = arguments[_key];\n  }\n\n  return [provideRoutes(routes), {\n    provide: ActivatedRoute,\n    useFactory: rootRoute,\n    deps: [Router]\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useFactory: getBootstrapListener\n  }, features.map(function (feature) {\n    return feature.ɵproviders;\n  }) // TODO: All options used by the `assignExtraOptionsToRouter` factory need to be reviewed for\n  // how we want them to be configured. This API doesn't currently have a way to configure them\n  // and we should decide what the _best_ way to do that is rather than just sticking with the\n  // status quo of how it's done today.\n  ];\n}\n\nfunction rootRoute(router) {\n  return router.routerState.root;\n}\n/**\n * Helper function to create an object that represents a Router feature.\n */\n\n\nfunction routerFeature(kind, providers) {\n  return {\n    ɵkind: kind,\n    ɵproviders: providers\n  };\n}\n/**\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```\n * @NgModule({\n *   providers: [provideRoutes(ROUTES)]\n * })\n * class LazyLoadedChildModule {}\n * ```\n *\n * @publicApi\n */\n\n\nfunction provideRoutes(routes) {\n  return [{\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }];\n}\n/**\n * Enables customizable scrolling behavior for router navigations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable scrolling feature:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withInMemoryScrolling())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n * @see `ViewportScroller`\n *\n * @publicApi\n * @developerPreview\n * @param options Set of configuration parameters to customize scrolling behavior, see\n *     `InMemoryScrollingOptions` for additional information.\n * @returns A set of providers for use with `provideRouter`.\n */\n\n\nfunction withInMemoryScrolling() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var providers = [{\n    provide: ROUTER_SCROLLER,\n    useFactory: function useFactory() {\n      var router = inject(Router);\n      var viewportScroller = inject(ViewportScroller);\n      return new RouterScroller(router, viewportScroller, options);\n    }\n  }];\n  return routerFeature(4\n  /* RouterFeatureKind.InMemoryScrollingFeature */\n  , providers);\n}\n\nfunction getBootstrapListener() {\n  var injector = inject(Injector);\n  return function (bootstrappedComponentRef) {\n    var _a, _b;\n\n    var ref = injector.get(ApplicationRef);\n\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n\n    var router = injector.get(Router);\n    var bootstrapDone = injector.get(BOOTSTRAP_DONE);\n\n    if (injector.get(INITIAL_NAVIGATION) === 1\n    /* InitialNavigation.EnabledNonBlocking */\n    ) {\n      router.initialNavigation();\n    }\n\n    (_a = injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)) === null || _a === void 0 ? void 0 : _a.setUpPreloading();\n    (_b = injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)) === null || _b === void 0 ? void 0 : _b.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    bootstrapDone.next();\n    bootstrapDone.complete();\n  };\n}\n/**\n * A subject used to indicate that the bootstrapping phase is done. When initial navigation is\n * `enabledBlocking`, the first navigation waits until bootstrapping is finished before continuing\n * to the activation phase.\n */\n\n\nvar BOOTSTRAP_DONE = /*#__PURE__*/new InjectionToken(NG_DEV_MODE$1 ? 'bootstrap done indicator' : '', {\n  factory: function factory() {\n    return new Subject();\n  }\n});\nvar INITIAL_NAVIGATION = /*#__PURE__*/new InjectionToken(NG_DEV_MODE$1 ? 'initial navigation' : '', {\n  providedIn: 'root',\n  factory: function factory() {\n    return 1;\n  }\n  /* InitialNavigation.EnabledNonBlocking */\n\n});\n/**\n * Configures initial navigation to start before the root component is created.\n *\n * The bootstrap is blocked until the initial navigation is complete. This value is required for\n * [server-side rendering](guide/universal) to work.\n *\n * @usageNotes\n *\n * Basic example of how you can enable this navigation behavior:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withEnabledBlockingInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @publicApi\n * @developerPreview\n * @returns A set of providers for use with `provideRouter`.\n */\n\nfunction withEnabledBlockingInitialNavigation() {\n  var providers = [{\n    provide: INITIAL_NAVIGATION,\n    useValue: 0\n    /* InitialNavigation.EnabledBlocking */\n\n  }, {\n    provide: APP_INITIALIZER,\n    multi: true,\n    deps: [Injector],\n    useFactory: function useFactory(injector) {\n      var locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());\n      var initNavigation = false;\n      /**\n       * Performs the given action once the router finishes its next/current navigation.\n       *\n       * If the navigation is canceled or errors without a redirect, the navigation is considered\n       * complete. If the `NavigationEnd` event emits, the navigation is also considered complete.\n       */\n\n      function afterNextNavigation(action) {\n        var router = injector.get(Router);\n        router.events.pipe(filter(function (e) {\n          return e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError;\n        }), map(function (e) {\n          if (e instanceof NavigationEnd) {\n            // Navigation assumed to succeed if we get `ActivationStart`\n            return true;\n          }\n\n          var redirecting = e instanceof NavigationCancel ? e.code === 0\n          /* NavigationCancellationCode.Redirect */\n          || e.code === 1\n          /* NavigationCancellationCode.SupersededByNewNavigation */\n          : false;\n          return redirecting ? null : false;\n        }), filter(function (result) {\n          return result !== null;\n        }), take(1)).subscribe(function () {\n          action();\n        });\n      }\n\n      return function () {\n        return locationInitialized.then(function () {\n          return new Promise(function (resolve) {\n            var router = injector.get(Router);\n            var bootstrapDone = injector.get(BOOTSTRAP_DONE);\n            afterNextNavigation(function () {\n              // Unblock APP_INITIALIZER in case the initial navigation was canceled or errored\n              // without a redirect.\n              resolve(true);\n              initNavigation = true;\n            });\n\n            router.afterPreactivation = function () {\n              // Unblock APP_INITIALIZER once we get to `afterPreactivation`. At this point, we\n              // assume activation will complete successfully (even though this is not\n              // guaranteed).\n              resolve(true); // only the initial navigation should be delayed until bootstrapping is done.\n\n              if (!initNavigation) {\n                return bootstrapDone.closed ? of(void 0) : bootstrapDone; // subsequent navigations should not be delayed\n              } else {\n                return of(void 0);\n              }\n            };\n\n            router.initialNavigation();\n          });\n        });\n      };\n    }\n  }];\n  return routerFeature(2\n  /* RouterFeatureKind.EnabledBlockingInitialNavigationFeature */\n  , providers);\n}\n/**\n * Disables initial navigation.\n *\n * Use if there is a reason to have more control over when the router starts its initial navigation\n * due to some complex initialization logic.\n *\n * @usageNotes\n *\n * Basic example of how you can disable initial navigation:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDisabledInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\n\n\nfunction withDisabledInitialNavigation() {\n  var providers = [{\n    provide: APP_INITIALIZER,\n    multi: true,\n    useFactory: function useFactory() {\n      var router = inject(Router);\n      return function () {\n        router.setUpLocationChangeListener();\n      };\n    }\n  }, {\n    provide: INITIAL_NAVIGATION,\n    useValue: 2\n    /* InitialNavigation.Disabled */\n\n  }];\n  return routerFeature(3\n  /* RouterFeatureKind.DisabledInitialNavigationFeature */\n  , providers);\n}\n/**\n * Enables logging of all internal navigation events to the console.\n * Extra logging might be useful for debugging purposes to inspect Router event sequence.\n *\n * @usageNotes\n *\n * Basic example of how you can enable debug tracing:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDebugTracing())\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\n\n\nfunction withDebugTracing() {\n  var providers = [];\n\n  if (NG_DEV_MODE$1) {\n    providers = [{\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: function useFactory() {\n        var router = inject(Router);\n        return function () {\n          return router.events.subscribe(function (e) {\n            var _a, _b; // tslint:disable:no-console\n\n\n            (_a = console.group) === null || _a === void 0 ? void 0 : _a.call(console, \"Router Event: \".concat(e.constructor.name));\n            console.log(stringifyEvent(e));\n            console.log(e);\n            (_b = console.groupEnd) === null || _b === void 0 ? void 0 : _b.call(console); // tslint:enable:no-console\n          });\n        };\n      }\n    }];\n  } else {\n    providers = [];\n  }\n\n  return routerFeature(1\n  /* RouterFeatureKind.DebugTracingFeature */\n  , providers);\n}\n\nvar ROUTER_PRELOADER = /*#__PURE__*/new InjectionToken(NG_DEV_MODE$1 ? 'router preloader' : '');\n/**\n * Allows to configure a preloading strategy to use. The strategy is configured by providing a\n * reference to a class that implements a `PreloadingStrategy`.\n *\n * @usageNotes\n *\n * Basic example of how you can configure preloading:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withPreloading(PreloadAllModules))\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @param preloadingStrategy A reference to a class that implements a `PreloadingStrategy` that\n *     should be used.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\n\nfunction withPreloading(preloadingStrategy) {\n  var providers = [{\n    provide: ROUTER_PRELOADER,\n    useExisting: RouterPreloader\n  }, {\n    provide: PreloadingStrategy,\n    useExisting: preloadingStrategy\n  }];\n  return routerFeature(0\n  /* RouterFeatureKind.PreloadingFeature */\n  , providers);\n}\n/**\n * Allows to provide extra parameters to configure Router.\n *\n * @usageNotes\n *\n * Basic example of how you can provide extra configuration options:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withRouterConfig({\n *          onSameUrlNavigation: 'reload'\n *       }))\n *     ]\n *   }\n * );\n * ```\n *\n * @see `provideRouter`\n *\n * @param options A set of parameters to configure Router, see `RouterConfigOptions` for\n *     additional information.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n * @developerPreview\n */\n\n\nfunction withRouterConfig(options) {\n  var providers = [{\n    provide: ROUTER_CONFIGURATION,\n    useValue: options\n  }];\n  return routerFeature(5\n  /* RouterFeatureKind.RouterConfigurationFeature */\n  , providers);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * The directives defined in the `RouterModule`.\n */\n\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent];\n/**\n * @docsNotRequired\n */\n\nvar ROUTER_FORROOT_GUARD = /*#__PURE__*/new InjectionToken(NG_DEV_MODE ? 'router duplicate forRoot guard' : 'ROUTER_FORROOT_GUARD'); // TODO(atscott): All of these except `ActivatedRoute` are `providedIn: 'root'`. They are only kept\n// here to avoid a breaking change whereby the provider order matters based on where the\n// `RouterModule`/`RouterTestingModule` is imported. These can/should be removed as a \"breaking\"\n// change in a major version.\n\nvar ROUTER_PROVIDERS = [Location, {\n  provide: UrlSerializer,\n  useClass: DefaultUrlSerializer\n}, {\n  provide: Router,\n  useFactory: setupRouter\n}, ChildrenOutletContexts, {\n  provide: ActivatedRoute,\n  useFactory: rootRoute,\n  deps: [Router]\n}, RouterConfigLoader];\n\nfunction routerNgProbeToken() {\n  return new NgProbeToken('Router', Router);\n}\n/**\n * @description\n *\n * Adds directives and providers for in-app navigation among views defined in an application.\n * Use the Angular `Router` service to declaratively specify application states and manage state\n * transitions.\n *\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\n * However, only one `Router` service can be active.\n * To ensure this, there are two ways to register routes when importing this module:\n *\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\n * routes, and the `Router` service itself.\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\n * routes, but does not include the `Router` service.\n *\n * @see [Routing and Navigation guide](guide/router) for an\n * overview of how the `Router` service should be used.\n *\n * @publicApi\n */\n\n\nvar RouterModule = /*#__PURE__*/(function () {\n  var RouterModule = /*#__PURE__*/function () {\n    function RouterModule(guard) {\n      _classCallCheck(this, RouterModule);\n    }\n    /**\n     * Creates and configures a module with all the router providers and directives.\n     * Optionally sets up an application listener to perform an initial navigation.\n     *\n     * When registering the NgModule at the root, import as follows:\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forRoot(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the application.\n     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n     * @return The new `NgModule`.\n     *\n     */\n\n\n    _createClass(RouterModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot(routes, config) {\n        return {\n          ngModule: RouterModule,\n          providers: [ROUTER_PROVIDERS, NG_DEV_MODE ? (config === null || config === void 0 ? void 0 : config.enableTracing) ? withDebugTracing().ɵproviders : [] : [], provideRoutes(routes), {\n            provide: ROUTER_FORROOT_GUARD,\n            useFactory: provideForRootGuard,\n            deps: [[Router, new Optional(), new SkipSelf()]]\n          }, {\n            provide: ROUTER_CONFIGURATION,\n            useValue: config ? config : {}\n          }, (config === null || config === void 0 ? void 0 : config.useHash) ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), (config === null || config === void 0 ? void 0 : config.preloadingStrategy) ? withPreloading(config.preloadingStrategy).ɵproviders : [], {\n            provide: NgProbeToken,\n            multi: true,\n            useFactory: routerNgProbeToken\n          }, (config === null || config === void 0 ? void 0 : config.initialNavigation) ? provideInitialNavigation(config) : [], provideRouterInitializer()]\n        };\n      }\n      /**\n       * Creates a module with all the router directives and a provider registering routes,\n       * without creating a new Router service.\n       * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\n       *\n       * ```\n       * @NgModule({\n       *   imports: [RouterModule.forChild(ROUTES)]\n       * })\n       * class MyNgModule {}\n       * ```\n       *\n       * @param routes An array of `Route` objects that define the navigation paths for the submodule.\n       * @return The new NgModule.\n       *\n       */\n\n    }, {\n      key: \"forChild\",\n      value: function forChild(routes) {\n        return {\n          ngModule: RouterModule,\n          providers: [provideRoutes(routes)]\n        };\n      }\n    }]);\n\n    return RouterModule;\n  }();\n\n  RouterModule.ɵfac = function RouterModule_Factory(t) {\n    return new (t || RouterModule)(i0.ɵɵinject(ROUTER_FORROOT_GUARD, 8));\n  };\n\n  RouterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: RouterModule\n  });\n  RouterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [ɵEmptyOutletComponent]\n  });\n  return RouterModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * For internal use by `RouterModule` only. Note that this differs from `withInMemoryRouterScroller`\n * because it reads from the `ExtraOptions` which should not be used in the standalone world.\n */\n\n\nfunction provideRouterScroller() {\n  return {\n    provide: ROUTER_SCROLLER,\n    useFactory: function useFactory() {\n      var router = inject(Router);\n      var viewportScroller = inject(ViewportScroller);\n      var config = inject(ROUTER_CONFIGURATION);\n\n      if (config.scrollOffset) {\n        viewportScroller.setOffset(config.scrollOffset);\n      }\n\n      return new RouterScroller(router, viewportScroller, config);\n    }\n  };\n} // Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` should\n// provide hash location directly via `{provide: LocationStrategy, useClass: HashLocationStrategy}`.\n\n\nfunction provideHashLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: HashLocationStrategy\n  };\n} // Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` does not\n// need this at all because `PathLocationStrategy` is the default factory for `LocationStrategy`.\n\n\nfunction providePathLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: PathLocationStrategy\n  };\n}\n\nfunction provideForRootGuard(router) {\n  if (NG_DEV_MODE && router) {\n    throw new ɵRuntimeError(4007\n    /* RuntimeErrorCode.FOR_ROOT_CALLED_TWICE */\n    , \"The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector.\" + \" Lazy loaded modules should use RouterModule.forChild() instead.\");\n  }\n\n  return 'guarded';\n} // Note: For internal use only with `RouterModule`. Standalone router setup with `provideRouter`\n// users call `withXInitialNavigation` directly.\n\n\nfunction provideInitialNavigation(config) {\n  return [config.initialNavigation === 'disabled' ? withDisabledInitialNavigation().ɵproviders : [], config.initialNavigation === 'enabledBlocking' ? withEnabledBlockingInitialNavigation().ɵproviders : []];\n} // TODO(atscott): This should not be in the public API\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\n\n\nvar ROUTER_INITIALIZER = /*#__PURE__*/new InjectionToken(NG_DEV_MODE ? 'Router Initializer' : '');\n\nfunction provideRouterInitializer() {\n  return [// ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just\n  // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.\n  {\n    provide: ROUTER_INITIALIZER,\n    useFactory: getBootstrapListener\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useExisting: ROUTER_INITIALIZER\n  }];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @publicApi\n */\n\n\nvar VERSION = /*#__PURE__*/new Version('14.2.10');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, NoPreloading, OutletContext, PRIMARY_OUTLET, PreloadAllModules, PreloadingStrategy, ROUTER_CONFIGURATION, ROUTER_INITIALIZER, ROUTES, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, Router, RouterEvent, RouterLink, RouterLinkActive, RouterLinkWithHref, RouterModule, RouterOutlet, RouterPreloader, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VERSION, convertToParamMap, createUrlTreeFromSnapshot, defaultUrlMatcher, provideRouter, provideRoutes, withDebugTracing, withDisabledInitialNavigation, withEnabledBlockingInitialNavigation, withInMemoryScrolling, withPreloading, withRouterConfig, ɵEmptyOutletComponent, ROUTER_PROVIDERS as ɵROUTER_PROVIDERS, assignExtraOptionsToRouter as ɵassignExtraOptionsToRouter, flatten as ɵflatten, withPreloading as ɵwithPreloading }; //# sourceMappingURL=router.mjs.map","map":null,"metadata":{},"sourceType":"module"}